class Ae{constructor(t,e,s,i,r){this.sender=t,this.receiver=e,this.message=s,this.delay=i,this.data=r}toJSON(){return{type:this.constructor.name,sender:this.sender.uuid,receiver:this.receiver.uuid,message:this.message,delay:this.delay,data:this.data}}fromJSON(t){return this.sender=t.sender,this.receiver=t.receiver,this.message=t.message,this.delay=t.delay,this.data=t.data,this}resolveReferences(t){return this.sender=t.get(this.sender),this.receiver=t.get(this.receiver),this}}class v{static setLevel(t){bt=t}static log(...t){bt<=v.LEVEL.LOG&&console.log(...t)}static warn(...t){bt<=v.LEVEL.WARN&&console.warn(...t)}static error(...t){bt<=v.LEVEL.ERROR&&console.error(...t)}}v.LEVEL=Object.freeze({LOG:0,WARN:1,ERROR:2,SILENT:3});let bt=v.LEVEL.WARN;class _s{constructor(){this.delayedTelegrams=new Array}deliver(t){const e=t.receiver;return e.handleMessage(t)===!1&&v.warn("YUKA.MessageDispatcher: Message not handled by receiver: %o",e),this}dispatch(t,e,s,i,r){const n=new Ae(t,e,s,i,r);return i<=0?this.deliver(n):this.delayedTelegrams.push(n),this}dispatchDelayedMessages(t){let e=this.delayedTelegrams.length;for(;e--;){const s=this.delayedTelegrams[e];s.delay-=t,s.delay<=0&&(this.deliver(s),this.delayedTelegrams.pop())}return this}clear(){return this.delayedTelegrams.length=0,this}toJSON(){const t={type:this.constructor.name,delayedTelegrams:new Array};for(let e=0,s=this.delayedTelegrams.length;e<s;e++){const i=this.delayedTelegrams[e];t.delayedTelegrams.push(i.toJSON())}return t}fromJSON(t){this.clear();const e=t.delayedTelegrams;for(let s=0,i=e.length;s<i;s++){const r=e[s],n=new Ae().fromJSON(r);this.delayedTelegrams.push(n)}return this}resolveReferences(t){const e=this.delayedTelegrams;for(let s=0,i=e.length;s<i;s++)e[s].resolveReferences(t);return this}}const M=new Array;for(let u=0;u<256;u++)M[u]=(u<16?"0":"")+u.toString(16);class J{static area(t,e,s){return(s.x-t.x)*(e.z-t.z)-(e.x-t.x)*(s.z-t.z)}static argmax(t){const e=Math.max(...t),s=[];for(let i=0,r=t.length;i<r;i++)t[i]===e&&s.push(i);return s}static choice(t,e=null){const s=Math.random();if(e===null)return t[Math.floor(Math.random()*t.length)];{let i=0;const r=t.map((n,o)=>(i+=e[o],i)).findIndex(n=>n>=s);return t[r]}}static clamp(t,e,s){return Math.max(e,Math.min(s,t))}static generateUUID(){const t=Math.random()*4294967295|0,e=Math.random()*4294967295|0,s=Math.random()*4294967295|0,i=Math.random()*4294967295|0;return(M[t&255]+M[t>>8&255]+M[t>>16&255]+M[t>>24&255]+"-"+M[e&255]+M[e>>8&255]+"-"+M[e>>16&15|64]+M[e>>24&255]+"-"+M[s&63|128]+M[s>>8&255]+"-"+M[s>>16&255]+M[s>>24&255]+M[i&255]+M[i>>8&255]+M[i>>16&255]+M[i>>24&255]).toUpperCase()}static randFloat(t,e){return t+Math.random()*(e-t)}static randInt(t,e){return t+Math.floor(Math.random()*(e-t+1))}}class l{constructor(t=0,e=0,s=0){this.x=t,this.y=e,this.z=s}set(t,e,s){return this.x=t,this.y=e,this.z=s,this}copy(t){return this.x=t.x,this.y=t.y,this.z=t.z,this}clone(){return new this.constructor().copy(this)}add(t){return this.x+=t.x,this.y+=t.y,this.z+=t.z,this}addScalar(t){return this.x+=t,this.y+=t,this.z+=t,this}addVectors(t,e){return this.x=t.x+e.x,this.y=t.y+e.y,this.z=t.z+e.z,this}sub(t){return this.x-=t.x,this.y-=t.y,this.z-=t.z,this}subScalar(t){return this.x-=t,this.y-=t,this.z-=t,this}subVectors(t,e){return this.x=t.x-e.x,this.y=t.y-e.y,this.z=t.z-e.z,this}multiply(t){return this.x*=t.x,this.y*=t.y,this.z*=t.z,this}multiplyScalar(t){return this.x*=t,this.y*=t,this.z*=t,this}multiplyVectors(t,e){return this.x=t.x*e.x,this.y=t.y*e.y,this.z=t.z*e.z,this}divide(t){return this.x/=t.x,this.y/=t.y,this.z/=t.z,this}divideScalar(t){return this.x/=t,this.y/=t,this.z/=t,this}divideVectors(t,e){return this.x=t.x/e.x,this.y=t.y/e.y,this.z=t.z/e.z,this}reflect(t){return this.sub(Ns.copy(t).multiplyScalar(2*this.dot(t)))}clamp(t,e){return this.x=Math.max(t.x,Math.min(e.x,this.x)),this.y=Math.max(t.y,Math.min(e.y,this.y)),this.z=Math.max(t.z,Math.min(e.z,this.z)),this}min(t){return this.x=Math.min(this.x,t.x),this.y=Math.min(this.y,t.y),this.z=Math.min(this.z,t.z),this}max(t){return this.x=Math.max(this.x,t.x),this.y=Math.max(this.y,t.y),this.z=Math.max(this.z,t.z),this}dot(t){return this.x*t.x+this.y*t.y+this.z*t.z}cross(t){const e=this.x,s=this.y,i=this.z;return this.x=s*t.z-i*t.y,this.y=i*t.x-e*t.z,this.z=e*t.y-s*t.x,this}crossVectors(t,e){const s=t.x,i=t.y,r=t.z,n=e.x,o=e.y,h=e.z;return this.x=i*h-r*o,this.y=r*n-s*h,this.z=s*o-i*n,this}angleTo(t){const e=Math.sqrt(this.squaredLength()*t.squaredLength());if(e===0)return 0;const s=this.dot(t)/e;return Math.acos(J.clamp(s,-1,1))}length(){return Math.sqrt(this.squaredLength())}squaredLength(){return this.dot(this)}manhattanLength(){return Math.abs(this.x)+Math.abs(this.y)+Math.abs(this.z)}distanceTo(t){return Math.sqrt(this.squaredDistanceTo(t))}squaredDistanceTo(t){const e=this.x-t.x,s=this.y-t.y,i=this.z-t.z;return e*e+s*s+i*i}manhattanDistanceTo(t){const e=this.x-t.x,s=this.y-t.y,i=this.z-t.z;return Math.abs(e)+Math.abs(s)+Math.abs(i)}normalize(){return this.divideScalar(this.length()||1)}applyMatrix4(t){const e=this.x,s=this.y,i=this.z,r=t.elements,n=1/(r[3]*e+r[7]*s+r[11]*i+r[15]);return this.x=(r[0]*e+r[4]*s+r[8]*i+r[12])*n,this.y=(r[1]*e+r[5]*s+r[9]*i+r[13])*n,this.z=(r[2]*e+r[6]*s+r[10]*i+r[14])*n,this}applyRotation(t){const e=this.x,s=this.y,i=this.z,r=t.x,n=t.y,o=t.z,h=t.w,a=h*e+n*i-o*s,c=h*s+o*e-r*i,d=h*i+r*s-n*e,p=-r*e-n*s-o*i;return this.x=a*h+p*-r+c*-o-d*-n,this.y=c*h+p*-n+d*-r-a*-o,this.z=d*h+p*-o+a*-n-c*-r,this}extractPositionFromMatrix(t){const e=t.elements;return this.x=e[12],this.y=e[13],this.z=e[14],this}transformDirection(t){const e=this.x,s=this.y,i=this.z,r=t.elements;return this.x=r[0]*e+r[4]*s+r[8]*i,this.y=r[1]*e+r[5]*s+r[9]*i,this.z=r[2]*e+r[6]*s+r[10]*i,this.normalize()}fromMatrix3Column(t,e){return this.fromArray(t.elements,e*3)}fromMatrix4Column(t,e){return this.fromArray(t.elements,e*4)}fromSpherical(t,e,s){const i=Math.sin(e)*t;return this.x=i*Math.sin(s),this.y=Math.cos(e)*t,this.z=i*Math.cos(s),this}fromArray(t,e=0){return this.x=t[e+0],this.y=t[e+1],this.z=t[e+2],this}toArray(t,e=0){return t[e+0]=this.x,t[e+1]=this.y,t[e+2]=this.z,t}equals(t){return t.x===this.x&&t.y===this.y&&t.z===this.z}}const Ns=new l,Te=new l(0,1,0),Je=new l,j=new l,De=new l,Re=new l,Xt=[2,2,1],Kt=[1,0,0];class Oe{constructor(){this.elements=[1,0,0,0,1,0,0,0,1]}set(t,e,s,i,r,n,o,h,a){const c=this.elements;return c[0]=t,c[3]=e,c[6]=s,c[1]=i,c[4]=r,c[7]=n,c[2]=o,c[5]=h,c[8]=a,this}copy(t){const e=this.elements,s=t.elements;return e[0]=s[0],e[1]=s[1],e[2]=s[2],e[3]=s[3],e[4]=s[4],e[5]=s[5],e[6]=s[6],e[7]=s[7],e[8]=s[8],this}clone(){return new this.constructor().copy(this)}identity(){return this.set(1,0,0,0,1,0,0,0,1),this}multiply(t){return this.multiplyMatrices(this,t)}premultiply(t){return this.multiplyMatrices(t,this)}multiplyMatrices(t,e){const s=t.elements,i=e.elements,r=this.elements,n=s[0],o=s[3],h=s[6],a=s[1],c=s[4],d=s[7],p=s[2],f=s[5],y=s[8],m=i[0],x=i[3],g=i[6],w=i[1],S=i[4],D=i[7],R=i[2],P=i[5],I=i[8];return r[0]=n*m+o*w+h*R,r[3]=n*x+o*S+h*P,r[6]=n*g+o*D+h*I,r[1]=a*m+c*w+d*R,r[4]=a*x+c*S+d*P,r[7]=a*g+c*D+d*I,r[2]=p*m+f*w+y*R,r[5]=p*x+f*S+y*P,r[8]=p*g+f*D+y*I,this}multiplyScalar(t){const e=this.elements;return e[0]*=t,e[3]*=t,e[6]*=t,e[1]*=t,e[4]*=t,e[7]*=t,e[2]*=t,e[5]*=t,e[8]*=t,this}extractBasis(t,e,s){return t.fromMatrix3Column(this,0),e.fromMatrix3Column(this,1),s.fromMatrix3Column(this,2),this}makeBasis(t,e,s){return this.set(t.x,e.x,s.x,t.y,e.y,s.y,t.z,e.z,s.z),this}lookAt(t,e,s){return Je.crossVectors(s,t).normalize(),j.crossVectors(Te,e).normalize(),j.squaredLength()===0&&(Re.copy(e).addScalar(Number.EPSILON),j.crossVectors(Te,Re).normalize()),De.crossVectors(e,j).normalize(),Y.makeBasis(j,De,e),vt.makeBasis(Je,s,t),this.multiplyMatrices(Y,vt.transpose()),this}transpose(){const t=this.elements;let e;return e=t[1],t[1]=t[3],t[3]=e,e=t[2],t[2]=t[6],t[6]=e,e=t[5],t[5]=t[7],t[7]=e,this}getElementIndex(t,e){return t*3+e}frobeniusNorm(){const t=this.elements;let e=0;for(let s=0;s<9;s++)e+=t[s]*t[s];return Math.sqrt(e)}offDiagonalFrobeniusNorm(){const t=this.elements;let e=0;for(let s=0;s<3;s++){const i=t[this.getElementIndex(Xt[s],Kt[s])];e+=2*i*i}return Math.sqrt(e)}eigenDecomposition(t){let e=0,s=0;const i=10;t.unitary.identity(),t.diagonal.copy(this);const r=t.unitary,n=t.diagonal,o=Number.EPSILON*n.frobeniusNorm();for(;s<i&&n.offDiagonalFrobeniusNorm()>o;)n.shurDecomposition(Y),vt.copy(Y).transpose(),n.multiply(Y),n.premultiply(vt),r.multiply(Y),++e>2&&(s++,e=0);return t}shurDecomposition(t){let e=0,s=1;const i=this.elements;for(let a=0;a<3;a++){const c=Math.abs(i[this.getElementIndex(Xt[a],Kt[a])]);c>e&&(e=c,s=a)}let r=1,n=0;const o=Kt[s],h=Xt[s];if(Math.abs(i[this.getElementIndex(h,o)])>Number.EPSILON){const a=i[this.getElementIndex(h,h)],c=i[this.getElementIndex(o,o)],d=i[this.getElementIndex(h,o)],p=(a-c)/2/d;let f;p<0?f=-1/(-p+Math.sqrt(1+p*p)):f=1/(p+Math.sqrt(1+p*p)),r=1/Math.sqrt(1+f*f),n=f*r}return t.identity(),t.elements[this.getElementIndex(o,o)]=r,t.elements[this.getElementIndex(h,h)]=r,t.elements[this.getElementIndex(h,o)]=n,t.elements[this.getElementIndex(o,h)]=-n,t}fromQuaternion(t){const e=this.elements,s=t.x,i=t.y,r=t.z,n=t.w,o=s+s,h=i+i,a=r+r,c=s*o,d=s*h,p=s*a,f=i*h,y=i*a,m=r*a,x=n*o,g=n*h,w=n*a;return e[0]=1-(f+m),e[3]=d-w,e[6]=p+g,e[1]=d+w,e[4]=1-(c+m),e[7]=y-x,e[2]=p-g,e[5]=y+x,e[8]=1-(c+f),this}fromMatrix4(t){const e=this.elements,s=t.elements;return e[0]=s[0],e[1]=s[1],e[2]=s[2],e[3]=s[4],e[4]=s[5],e[5]=s[6],e[6]=s[8],e[7]=s[9],e[8]=s[10],this}fromArray(t,e=0){const s=this.elements;for(let i=0;i<9;i++)s[i]=t[i+e];return this}toArray(t,e=0){const s=this.elements;return t[e+0]=s[0],t[e+1]=s[1],t[e+2]=s[2],t[e+3]=s[3],t[e+4]=s[4],t[e+5]=s[5],t[e+6]=s[6],t[e+7]=s[7],t[e+8]=s[8],t}equals(t){const e=this.elements,s=t.elements;for(let i=0;i<9;i++)if(e[i]!==s[i])return!1;return!0}}const Y=new Oe,vt=new Oe,zt=new Oe,Gt=new l;class Yt{constructor(t=0,e=0,s=0,i=1){this.x=t,this.y=e,this.z=s,this.w=i}set(t,e,s,i){return this.x=t,this.y=e,this.z=s,this.w=i,this}copy(t){return this.x=t.x,this.y=t.y,this.z=t.z,this.w=t.w,this}clone(){return new this.constructor().copy(this)}inverse(){return this.conjugate().normalize()}conjugate(){return this.x*=-1,this.y*=-1,this.z*=-1,this}dot(t){return this.x*t.x+this.y*t.y+this.z*t.z+this.w*t.w}length(){return Math.sqrt(this.squaredLength())}squaredLength(){return this.dot(this)}normalize(){let t=this.length();return t===0?(this.x=0,this.y=0,this.z=0,this.w=1):(t=1/t,this.x=this.x*t,this.y=this.y*t,this.z=this.z*t,this.w=this.w*t),this}multiply(t){return this.multiplyQuaternions(this,t)}premultiply(t){return this.multiplyQuaternions(t,this)}multiplyQuaternions(t,e){const s=t.x,i=t.y,r=t.z,n=t.w,o=e.x,h=e.y,a=e.z,c=e.w;return this.x=s*c+n*o+i*a-r*h,this.y=i*c+n*h+r*o-s*a,this.z=r*c+n*a+s*h-i*o,this.w=n*c-s*o-i*h-r*a,this}angleTo(t){return 2*Math.acos(Math.abs(J.clamp(this.dot(t),-1,1)))}rotateTo(t,e,s=1e-4){const i=this.angleTo(t);if(i<s)return!0;const r=Math.min(1,e/i);return this.slerp(t,r),!1}lookAt(t,e,s){zt.lookAt(t,e,s),this.fromMatrix3(zt)}slerp(t,e){if(e===0)return this;if(e===1)return this.copy(t);const s=this.x,i=this.y,r=this.z,n=this.w;let o=n*t.w+s*t.x+i*t.y+r*t.z;if(o<0?(this.w=-t.w,this.x=-t.x,this.y=-t.y,this.z=-t.z,o=-o):this.copy(t),o>=1)return this.w=n,this.x=s,this.y=i,this.z=r,this;const h=Math.sqrt(1-o*o);if(Math.abs(h)<.001)return this.w=.5*(n+this.w),this.x=.5*(s+this.x),this.y=.5*(i+this.y),this.z=.5*(r+this.z),this;const a=Math.atan2(h,o),c=Math.sin((1-e)*a)/h,d=Math.sin(e*a)/h;return this.w=n*c+this.w*d,this.x=s*c+this.x*d,this.y=i*c+this.y*d,this.z=r*c+this.z*d,this}extractRotationFromMatrix(t){const e=zt.elements,s=t.elements,i=1/Gt.fromMatrix4Column(t,0).length(),r=1/Gt.fromMatrix4Column(t,1).length(),n=1/Gt.fromMatrix4Column(t,2).length();return e[0]=s[0]*i,e[1]=s[1]*i,e[2]=s[2]*i,e[3]=s[4]*r,e[4]=s[5]*r,e[5]=s[6]*r,e[6]=s[8]*n,e[7]=s[9]*n,e[8]=s[10]*n,this.fromMatrix3(zt),this}fromEuler(t,e,s){const i=Math.cos(e/2),r=Math.cos(t/2),n=Math.cos(s/2),o=Math.sin(e/2),h=Math.sin(t/2),a=Math.sin(s/2);return this.w=i*r*n+o*h*a,this.x=i*h*n+o*r*a,this.y=o*r*n-i*h*a,this.z=i*r*a-o*h*n,this}toEuler(t){const e=-2*(this.y*this.z-this.x*this.w);return Math.abs(e)>.9999?(t.x=Math.PI*.5*e,t.y=Math.atan2(this.x*this.z+this.w*this.y,.5-this.x*this.x-this.y*this.y),t.z=0):(t.x=Math.asin(e),t.y=Math.atan2(this.x*this.z+this.w*this.y,.5-this.x*this.x-this.y*this.y),t.z=Math.atan2(this.x*this.y+this.w*this.z,.5-this.x*this.x-this.z*this.z)),t}fromMatrix3(t){const e=t.elements,s=e[0],i=e[3],r=e[6],n=e[1],o=e[4],h=e[7],a=e[2],c=e[5],d=e[8],p=s+o+d;if(p>0){let f=.5/Math.sqrt(p+1);this.w=.25/f,this.x=(c-h)*f,this.y=(r-a)*f,this.z=(n-i)*f}else if(s>o&&s>d){let f=2*Math.sqrt(1+s-o-d);this.w=(c-h)/f,this.x=.25*f,this.y=(i+n)/f,this.z=(r+a)/f}else if(o>d){let f=2*Math.sqrt(1+o-s-d);this.w=(r-a)/f,this.x=(i+n)/f,this.y=.25*f,this.z=(h+c)/f}else{let f=2*Math.sqrt(1+d-s-o);this.w=(n-i)/f,this.x=(r+a)/f,this.y=(h+c)/f,this.z=.25*f}return this}fromArray(t,e=0){return this.x=t[e+0],this.y=t[e+1],this.z=t[e+2],this.w=t[e+3],this}toArray(t,e=0){return t[e+0]=this.x,t[e+1]=this.y,t[e+2]=this.z,t[e+3]=this.w,t}equals(t){return t.x===this.x&&t.y===this.y&&t.z===this.z&&t.w===this.w}}class Q{constructor(){this.elements=[1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1]}set(t,e,s,i,r,n,o,h,a,c,d,p,f,y,m,x){const g=this.elements;return g[0]=t,g[4]=e,g[8]=s,g[12]=i,g[1]=r,g[5]=n,g[9]=o,g[13]=h,g[2]=a,g[6]=c,g[10]=d,g[14]=p,g[3]=f,g[7]=y,g[11]=m,g[15]=x,this}copy(t){const e=this.elements,s=t.elements;return e[0]=s[0],e[1]=s[1],e[2]=s[2],e[3]=s[3],e[4]=s[4],e[5]=s[5],e[6]=s[6],e[7]=s[7],e[8]=s[8],e[9]=s[9],e[10]=s[10],e[11]=s[11],e[12]=s[12],e[13]=s[13],e[14]=s[14],e[15]=s[15],this}clone(){return new this.constructor().copy(this)}identity(){return this.set(1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1),this}multiply(t){return this.multiplyMatrices(this,t)}premultiply(t){return this.multiplyMatrices(t,this)}multiplyMatrices(t,e){const s=t.elements,i=e.elements,r=this.elements,n=s[0],o=s[4],h=s[8],a=s[12],c=s[1],d=s[5],p=s[9],f=s[13],y=s[2],m=s[6],x=s[10],g=s[14],w=s[3],S=s[7],D=s[11],R=s[15],P=i[0],I=i[4],L=i[8],b=i[12],ct=i[1],lt=i[5],ut=i[9],dt=i[13],pt=i[2],ft=i[6],gt=i[10],mt=i[14],yt=i[3],xt=i[7],wt=i[11],St=i[15];return r[0]=n*P+o*ct+h*pt+a*yt,r[4]=n*I+o*lt+h*ft+a*xt,r[8]=n*L+o*ut+h*gt+a*wt,r[12]=n*b+o*dt+h*mt+a*St,r[1]=c*P+d*ct+p*pt+f*yt,r[5]=c*I+d*lt+p*ft+f*xt,r[9]=c*L+d*ut+p*gt+f*wt,r[13]=c*b+d*dt+p*mt+f*St,r[2]=y*P+m*ct+x*pt+g*yt,r[6]=y*I+m*lt+x*ft+g*xt,r[10]=y*L+m*ut+x*gt+g*wt,r[14]=y*b+m*dt+x*mt+g*St,r[3]=w*P+S*ct+D*pt+R*yt,r[7]=w*I+S*lt+D*ft+R*xt,r[11]=w*L+S*ut+D*gt+R*wt,r[15]=w*b+S*dt+D*mt+R*St,this}multiplyScalar(t){const e=this.elements;return e[0]*=t,e[4]*=t,e[8]*=t,e[12]*=t,e[1]*=t,e[5]*=t,e[9]*=t,e[13]*=t,e[2]*=t,e[6]*=t,e[10]*=t,e[14]*=t,e[3]*=t,e[7]*=t,e[11]*=t,e[15]*=t,this}extractBasis(t,e,s){return t.fromMatrix4Column(this,0),e.fromMatrix4Column(this,1),s.fromMatrix4Column(this,2),this}makeBasis(t,e,s){return this.set(t.x,e.x,s.x,0,t.y,e.y,s.y,0,t.z,e.z,s.z,0,0,0,0,1),this}compose(t,e,s){return this.fromQuaternion(e),this.scale(s),this.setPosition(t),this}scale(t){const e=this.elements,s=t.x,i=t.y,r=t.z;return e[0]*=s,e[4]*=i,e[8]*=r,e[1]*=s,e[5]*=i,e[9]*=r,e[2]*=s,e[6]*=i,e[10]*=r,e[3]*=s,e[7]*=i,e[11]*=r,this}setPosition(t){const e=this.elements;return e[12]=t.x,e[13]=t.y,e[14]=t.z,this}transpose(){const t=this.elements;let e;return e=t[1],t[1]=t[4],t[4]=e,e=t[2],t[2]=t[8],t[8]=e,e=t[6],t[6]=t[9],t[9]=e,e=t[3],t[3]=t[12],t[12]=e,e=t[7],t[7]=t[13],t[13]=e,e=t[11],t[11]=t[14],t[14]=e,this}getInverse(t){const e=this.elements,s=t.elements,i=e[0],r=e[1],n=e[2],o=e[3],h=e[4],a=e[5],c=e[6],d=e[7],p=e[8],f=e[9],y=e[10],m=e[11],x=e[12],g=e[13],w=e[14],S=e[15],D=f*w*d-g*y*d+g*c*m-a*w*m-f*c*S+a*y*S,R=x*y*d-p*w*d-x*c*m+h*w*m+p*c*S-h*y*S,P=p*g*d-x*f*d+x*a*m-h*g*m-p*a*S+h*f*S,I=x*f*c-p*g*c-x*a*y+h*g*y+p*a*w-h*f*w,L=i*D+r*R+n*P+o*I;if(L===0)return t.set(0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0);const b=1/L;return s[0]=D*b,s[1]=(g*y*o-f*w*o-g*n*m+r*w*m+f*n*S-r*y*S)*b,s[2]=(a*w*o-g*c*o+g*n*d-r*w*d-a*n*S+r*c*S)*b,s[3]=(f*c*o-a*y*o-f*n*d+r*y*d+a*n*m-r*c*m)*b,s[4]=R*b,s[5]=(p*w*o-x*y*o+x*n*m-i*w*m-p*n*S+i*y*S)*b,s[6]=(x*c*o-h*w*o-x*n*d+i*w*d+h*n*S-i*c*S)*b,s[7]=(h*y*o-p*c*o+p*n*d-i*y*d-h*n*m+i*c*m)*b,s[8]=P*b,s[9]=(x*f*o-p*g*o-x*r*m+i*g*m+p*r*S-i*f*S)*b,s[10]=(h*g*o-x*a*o+x*r*d-i*g*d-h*r*S+i*a*S)*b,s[11]=(p*a*o-h*f*o-p*r*d+i*f*d+h*r*m-i*a*m)*b,s[12]=I*b,s[13]=(p*g*n-x*f*n+x*r*y-i*g*y-p*r*w+i*f*w)*b,s[14]=(x*a*n-h*g*n-x*r*c+i*g*c+h*r*w-i*a*w)*b,s[15]=(h*f*n-p*a*n+p*r*c-i*f*c-h*r*y+i*a*y)*b,t}getMaxScale(){const t=this.elements,e=t[0]*t[0]+t[1]*t[1]+t[2]*t[2],s=t[4]*t[4]+t[5]*t[5]+t[6]*t[6],i=t[8]*t[8]+t[9]*t[9]+t[10]*t[10];return Math.sqrt(Math.max(e,s,i))}fromQuaternion(t){const e=this.elements,s=t.x,i=t.y,r=t.z,n=t.w,o=s+s,h=i+i,a=r+r,c=s*o,d=s*h,p=s*a,f=i*h,y=i*a,m=r*a,x=n*o,g=n*h,w=n*a;return e[0]=1-(f+m),e[4]=d-w,e[8]=p+g,e[1]=d+w,e[5]=1-(c+m),e[9]=y-x,e[2]=p-g,e[6]=y+x,e[10]=1-(c+f),e[3]=0,e[7]=0,e[11]=0,e[12]=0,e[13]=0,e[14]=0,e[15]=1,this}fromMatrix3(t){const e=this.elements,s=t.elements;return e[0]=s[0],e[1]=s[1],e[2]=s[2],e[3]=0,e[4]=s[3],e[5]=s[4],e[6]=s[5],e[7]=0,e[8]=s[6],e[9]=s[7],e[10]=s[8],e[11]=0,e[12]=0,e[13]=0,e[14]=0,e[15]=1,this}fromArray(t,e=0){const s=this.elements;for(let i=0;i<16;i++)s[i]=t[i+e];return this}toArray(t,e=0){const s=this.elements;return t[e+0]=s[0],t[e+1]=s[1],t[e+2]=s[2],t[e+3]=s[3],t[e+4]=s[4],t[e+5]=s[5],t[e+6]=s[6],t[e+7]=s[7],t[e+8]=s[8],t[e+9]=s[9],t[e+10]=s[10],t[e+11]=s[11],t[e+12]=s[12],t[e+13]=s[13],t[e+14]=s[14],t[e+15]=s[15],t}equals(t){const e=this.elements,s=t.elements;for(let i=0;i<16;i++)if(e[i]!==s[i])return!1;return!0}}const Ot=new Yt,C=new l,Mt=new l,W=new Yt;class Me{constructor(){this.name="",this.active=!0,this.children=new Array,this.parent=null,this.neighbors=new Array,this.neighborhoodRadius=1,this.updateNeighborhood=!1,this.position=new l,this.rotation=new Yt,this.scale=new l(1,1,1),this.forward=new l(0,0,1),this.up=new l(0,1,0),this.boundingRadius=0,this.maxTurnRate=Math.PI,this.canActivateTrigger=!0,this.manager=null,this._localMatrix=new Q,this._worldMatrix=new Q,this._cache={position:new l,rotation:new Yt,scale:new l(1,1,1)},this._renderComponent=null,this._renderComponentCallback=null,this._started=!1,this._uuid=null,this._worldMatrixDirty=!1}get worldMatrix(){return this._updateWorldMatrix(),this._worldMatrix}get uuid(){return this._uuid===null&&(this._uuid=J.generateUUID()),this._uuid}start(){return this}update(){return this}add(t){return t.parent!==null&&t.parent.remove(t),this.children.push(t),t.parent=this,this}remove(t){const e=this.children.indexOf(t);return this.children.splice(e,1),t.parent=null,this}getDirection(t){return t.copy(this.forward).applyRotation(this.rotation).normalize()}lookAt(t){const e=this.parent;return e!==null?(this.getWorldPosition(Mt),C.subVectors(t,Mt).normalize(),this.rotation.lookAt(this.forward,C,this.up),W.extractRotationFromMatrix(e.worldMatrix).inverse(),this.rotation.premultiply(W)):(C.subVectors(t,this.position).normalize(),this.rotation.lookAt(this.forward,C,this.up)),this}rotateTo(t,e,s=1e-4){const i=this.parent;return i!==null?(this.getWorldPosition(Mt),C.subVectors(t,Mt).normalize(),Ot.lookAt(this.forward,C,this.up),W.extractRotationFromMatrix(i.worldMatrix).inverse(),Ot.premultiply(W)):(C.subVectors(t,this.position).normalize(),Ot.lookAt(this.forward,C,this.up)),this.rotation.rotateTo(Ot,this.maxTurnRate*e,s)}getWorldDirection(t){return W.extractRotationFromMatrix(this.worldMatrix),t.copy(this.forward).applyRotation(W).normalize()}getWorldPosition(t){return t.extractPositionFromMatrix(this.worldMatrix)}setRenderComponent(t,e){return this._renderComponent=t,this._renderComponentCallback=e,this}handleMessage(){return!1}lineOfSightTest(){return null}sendMessage(t,e,s=0,i=null){return this.manager!==null?this.manager.sendMessage(this,t,e,s,i):v.error("YUKA.GameEntity: The game entity must be added to a manager in order to send a message."),this}toJSON(){return{type:this.constructor.name,uuid:this.uuid,name:this.name,active:this.active,children:Pe(this.children),parent:this.parent!==null?this.parent.uuid:null,neighbors:Pe(this.neighbors),neighborhoodRadius:this.neighborhoodRadius,updateNeighborhood:this.updateNeighborhood,position:this.position.toArray(new Array),rotation:this.rotation.toArray(new Array),scale:this.scale.toArray(new Array),forward:this.forward.toArray(new Array),up:this.up.toArray(new Array),boundingRadius:this.boundingRadius,maxTurnRate:this.maxTurnRate,canActivateTrigger:this.canActivateTrigger,worldMatrix:this.worldMatrix.toArray(new Array),_localMatrix:this._localMatrix.toArray(new Array),_cache:{position:this._cache.position.toArray(new Array),rotation:this._cache.rotation.toArray(new Array),scale:this._cache.scale.toArray(new Array)},_started:this._started}}fromJSON(t){return this.name=t.name,this.active=t.active,this.neighborhoodRadius=t.neighborhoodRadius,this.updateNeighborhood=t.updateNeighborhood,this.position.fromArray(t.position),this.rotation.fromArray(t.rotation),this.scale.fromArray(t.scale),this.forward.fromArray(t.forward),this.up.fromArray(t.up),this.boundingRadius=t.boundingRadius,this.maxTurnRate=t.maxTurnRate,this.canActivateTrigger=t.canActivateTrigger,this.children=t.children.slice(),this.neighbors=t.neighbors.slice(),this.parent=t.parent,this._localMatrix.fromArray(t._localMatrix),this._worldMatrix.fromArray(t.worldMatrix),this._cache.position.fromArray(t._cache.position),this._cache.rotation.fromArray(t._cache.rotation),this._cache.scale.fromArray(t._cache.scale),this._started=t._started,this._uuid=t.uuid,this}resolveReferences(t){const e=this.neighbors;for(let i=0,r=e.length;i<r;i++)e[i]=t.get(e[i]);const s=this.children;for(let i=0,r=s.length;i<r;i++)s[i]=t.get(s[i]);return this.parent=t.get(this.parent)||null,this}_updateMatrix(){const t=this._cache;t.position.equals(this.position)&&t.rotation.equals(this.rotation)&&t.scale.equals(this.scale)||(this._localMatrix.compose(this.position,this.rotation,this.scale),t.position.copy(this.position),t.rotation.copy(this.rotation),t.scale.copy(this.scale),this._worldMatrixDirty=!0)}_updateWorldMatrix(){const t=this.parent;if(t!==null&&t._updateWorldMatrix(),this._updateMatrix(),this._worldMatrixDirty===!0){t===null?this._worldMatrix.copy(this._localMatrix):this._worldMatrix.multiplyMatrices(this.parent._worldMatrix,this._localMatrix),this._worldMatrixDirty=!1;const e=this.children;for(let s=0,i=e.length;s<i;s++){const r=e[s];r._worldMatrixDirty=!0}}}updateWorldMatrix(){return console.warn("GameEntity: .updateWorldMatrix() has been removed. World matrices are automatically updated on access."),this}}function Pe(u){const t=new Array;for(let e=0,s=u.length;e<s;e++)t.push(u[e].uuid);return t}const Ie=new l,Qt=new l;class ys extends Me{constructor(){super(),this.velocity=new l,this.maxSpeed=1,this.updateOrientation=!0}update(t){return this.getSpeedSquared()>this.maxSpeed*this.maxSpeed&&(this.velocity.normalize(),this.velocity.multiplyScalar(this.maxSpeed)),Ie.copy(this.velocity).multiplyScalar(t),Qt.copy(this.position).add(Ie),this.updateOrientation&&this.getSpeedSquared()>1e-8&&this.lookAt(Qt),this.position.copy(Qt),this}getSpeed(){return this.velocity.length()}getSpeedSquared(){return this.velocity.squaredLength()}toJSON(){const t=super.toJSON();return t.velocity=this.velocity.toArray(new Array),t.maxSpeed=this.maxSpeed,t.updateOrientation=this.updateOrientation,t}fromJSON(t){return super.fromJSON(t),this.velocity.fromArray(t.velocity),this.maxSpeed=t.maxSpeed,this.updateOrientation=t.updateOrientation,this}}class N{constructor(){this.active=!0,this.weight=1}calculate(){}toJSON(){return{type:this.constructor.name,active:this.active,weight:this.weight}}fromJSON(t){return this.active=t.active,this.weight=t.weight,this}resolveReferences(){}}const _t=new l,Nt=new l;class As extends N{constructor(){super()}calculate(t,e){_t.set(0,0,0);const s=t.neighbors;for(let i=0,r=s.length;i<r;i++)s[i].getDirection(Nt),_t.add(Nt);return s.length>0&&(_t.divideScalar(s.length),t.getDirection(Nt),e.subVectors(_t,Nt)),e}}const jt=new l,te=new l;class $t extends N{constructor(t=new l,e=3,s=0){super(),this.target=t,this.deceleration=e,this.tolerance=s}calculate(t,e){const s=this.target,i=this.deceleration;te.subVectors(s,t.position);const r=te.length();if(r>this.tolerance){let n=r/i;n=Math.min(n,t.maxSpeed),jt.copy(te).multiplyScalar(n/r)}else jt.set(0,0,0);return e.subVectors(jt,t.velocity)}toJSON(){const t=super.toJSON();return t.target=this.target.toArray(new Array),t.deceleration=this.deceleration,t}fromJSON(t){return super.fromJSON(t),this.target.fromArray(t.target),this.deceleration=t.deceleration,this}}const ee=new l;class at extends N{constructor(t=new l){super(),this.target=t}calculate(t,e){const s=this.target;return ee.subVectors(s,t.position).normalize(),ee.multiplyScalar(t.maxSpeed),e.subVectors(ee,t.velocity)}toJSON(){const t=super.toJSON();return t.target=this.target.toArray(new Array),t}fromJSON(t){return super.fromJSON(t),this.target.fromArray(t.target),this}}const At=new l;class Ts extends N{constructor(){super(),this._seek=new at}calculate(t,e){At.set(0,0,0);const s=t.neighbors;for(let i=0,r=s.length;i<r;i++){const n=s[i];At.add(n.position)}return s.length>0&&(At.divideScalar(s.length),this._seek.target=At,this._seek.calculate(t,e),e.normalize()),e}}const tt=new l;class xs extends N{constructor(t=new l,e=10){super(),this.target=t,this.panicDistance=e}calculate(t,e){const s=this.target;return t.position.squaredDistanceTo(s)<=this.panicDistance*this.panicDistance&&(tt.subVectors(t.position,s).normalize(),tt.squaredLength()===0&&tt.set(0,0,1),tt.multiplyScalar(t.maxSpeed),e.subVectors(tt,t.velocity)),e}toJSON(){const t=super.toJSON();return t.target=this.target.toArray(new Array),t.panicDistance=this.panicDistance,t}fromJSON(t){return super.fromJSON(t),this.target.fromArray(t.target),this.panicDistance=t.panicDistance,this}}const Ee=new l,Ve=new l,ke=new l;class Js extends N{constructor(t=null,e=10,s=1){super(),this.pursuer=t,this.panicDistance=e,this.predictionFactor=s,this._flee=new xs}calculate(t,e){const s=this.pursuer;Ee.subVectors(s.position,t.position);let i=Ee.length()/(t.maxSpeed+s.getSpeed());return i*=this.predictionFactor,Ve.copy(s.velocity).multiplyScalar(i),ke.addVectors(s.position,Ve),this._flee.target=ke,this._flee.panicDistance=this.panicDistance,this._flee.calculate(t,e),e}toJSON(){const t=super.toJSON();return t.pursuer=this.pursuer?this.pursuer.uuid:null,t.panicDistance=this.panicDistance,t.predictionFactor=this.predictionFactor,t}fromJSON(t){return super.fromJSON(t),this.pursuer=t.pursuer,this.panicDistance=t.panicDistance,this.predictionFactor=t.predictionFactor,this}resolveReferences(t){this.pursuer=t.get(this.pursuer)||null}}class ws{constructor(){this.loop=!1,this._waypoints=new Array,this._index=0}add(t){return this._waypoints.push(t),this}clear(){return this._waypoints.length=0,this._index=0,this}current(){return this._waypoints[this._index]}finished(){const t=this._waypoints.length-1;return this.loop===!0?!1:this._index===t}advance(){return this._index++,this._index===this._waypoints.length&&(this.loop===!0?this._index=0:this._index--),this}toJSON(){const t={type:this.constructor.name,loop:this.loop,_waypoints:new Array,_index:this._index},e=this._waypoints;for(let s=0,i=e.length;s<i;s++){const r=e[s];t._waypoints.push(r.toArray(new Array))}return t}fromJSON(t){this.loop=t.loop,this._index=t._index;const e=t._waypoints;for(let s=0,i=e.length;s<i;s++){const r=e[s];this._waypoints.push(new l().fromArray(r))}return this}}class Ds extends N{constructor(t=new ws,e=1){super(),this.path=t,this.nextWaypointDistance=e,this._arrive=new $t,this._seek=new at}calculate(t,e){const s=this.path;s.current().squaredDistanceTo(t.position)<this.nextWaypointDistance*this.nextWaypointDistance&&s.advance();const r=s.current();return s.finished()===!0?(this._arrive.target=r,this._arrive.calculate(t,e)):(this._seek.target=r,this._seek.calculate(t,e)),e}toJSON(){const t=super.toJSON();return t.path=this.path.toJSON(),t.nextWaypointDistance=this.nextWaypointDistance,t}fromJSON(t){return super.fromJSON(t),this.path.fromJSON(t.path),this.nextWaypointDistance=t.nextWaypointDistance,this}}const Tt=new l,Jt=new l,Ce=new l,Fe=new l;class Rs extends N{constructor(t=null,e=null,s=3){super(),this.entity1=t,this.entity2=e,this.deceleration=s,this._arrive=new $t}calculate(t,e){const s=this.entity1,i=this.entity2;Tt.addVectors(s.position,i.position).multiplyScalar(.5);const r=t.position.distanceTo(Tt)/t.maxSpeed;return Jt.copy(s.velocity).multiplyScalar(r),Ce.addVectors(s.position,Jt),Jt.copy(i.velocity).multiplyScalar(r),Fe.addVectors(i.position,Jt),Tt.addVectors(Ce,Fe).multiplyScalar(.5),this._arrive.deceleration=this.deceleration,this._arrive.target=Tt,this._arrive.calculate(t,e),e}toJSON(){const t=super.toJSON();return t.entity1=this.entity1?this.entity1.uuid:null,t.entity2=this.entity2?this.entity2.uuid:null,t.deceleration=this.deceleration,t}fromJSON(t){return super.fromJSON(t),this.entity1=t.entity1,this.entity2=t.entity2,this.deceleration=t.deceleration,this}resolveReferences(t){this.entity1=t.get(this.entity1)||null,this.entity2=t.get(this.entity2)||null}}const A=new l,et=new l,F=new l,E=[new l,new l,new l,new l,new l,new l,new l,new l];class k{constructor(t=new l,e=new l){this.min=t,this.max=e}set(t,e){return this.min=t,this.max=e,this}copy(t){return this.min.copy(t.min),this.max.copy(t.max),this}clone(){return new this.constructor().copy(this)}clampPoint(t,e){return e.copy(t).clamp(this.min,this.max),e}containsPoint(t){return!(t.x<this.min.x||t.x>this.max.x||t.y<this.min.y||t.y>this.max.y||t.z<this.min.z||t.z>this.max.z)}expand(t){return this.min.min(t),this.max.max(t),this}getCenter(t){return t.addVectors(this.min,this.max).multiplyScalar(.5)}getSize(t){return t.subVectors(this.max,this.min)}intersectsAABB(t){return!(t.max.x<this.min.x||t.min.x>this.max.x||t.max.y<this.min.y||t.min.y>this.max.y||t.max.z<this.min.z||t.min.z>this.max.z)}intersectsBoundingSphere(t){return this.clampPoint(t.center,A),A.squaredDistanceTo(t.center)<=t.radius*t.radius}intersectsPlane(t){const e=t.normal;this.getCenter(et),F.subVectors(this.max,et);const s=F.x*Math.abs(e.x)+F.y*Math.abs(e.y)+F.z*Math.abs(e.z),i=t.distanceToPoint(et);return Math.abs(i)<=s}getNormalFromSurfacePoint(t,e){e.set(0,0,0);let s,i=1/0;return this.getCenter(et),this.getSize(F),A.copy(t).sub(et),s=Math.abs(F.x-Math.abs(A.x)),s<i&&(i=s,e.set(1*Math.sign(A.x),0,0)),s=Math.abs(F.y-Math.abs(A.y)),s<i&&(i=s,e.set(0,1*Math.sign(A.y),0)),s=Math.abs(F.z-Math.abs(A.z)),s<i&&e.set(0,0,1*Math.sign(A.z)),e}fromCenterAndSize(t,e){return A.copy(e).multiplyScalar(.5),this.min.copy(t).sub(A),this.max.copy(t).add(A),this}fromPoints(t){this.min.set(1/0,1/0,1/0),this.max.set(-1/0,-1/0,-1/0);for(let e=0,s=t.length;e<s;e++)this.expand(t[e]);return this}applyMatrix4(t){const e=this.min,s=this.max;return E[0].set(e.x,e.y,e.z).applyMatrix4(t),E[1].set(e.x,e.y,s.z).applyMatrix4(t),E[2].set(e.x,s.y,e.z).applyMatrix4(t),E[3].set(e.x,s.y,s.z).applyMatrix4(t),E[4].set(s.x,e.y,e.z).applyMatrix4(t),E[5].set(s.x,e.y,s.z).applyMatrix4(t),E[6].set(s.x,s.y,e.z).applyMatrix4(t),E[7].set(s.x,s.y,s.z).applyMatrix4(t),this.fromPoints(E)}equals(t){return t.min.equals(this.min)&&t.max.equals(this.max)}toJSON(){return{type:this.constructor.name,min:this.min.toArray(new Array),max:this.max.toArray(new Array)}}fromJSON(t){return this.min.fromArray(t.min),this.max.fromArray(t.max),this}}const se=new k;class U{constructor(t=new l,e=0){this.center=t,this.radius=e}set(t,e){return this.center=t,this.radius=e,this}copy(t){return this.center.copy(t.center),this.radius=t.radius,this}clone(){return new this.constructor().copy(this)}clampPoint(t,e){return e.copy(t),this.center.squaredDistanceTo(t)>this.radius*this.radius&&(e.sub(this.center).normalize(),e.multiplyScalar(this.radius).add(this.center)),e}containsPoint(t){return t.squaredDistanceTo(this.center)<=this.radius*this.radius}intersectsBoundingSphere(t){const e=this.radius+t.radius;return t.center.squaredDistanceTo(this.center)<=e*e}intersectsPlane(t){return Math.abs(t.distanceToPoint(this.center))<=this.radius}getNormalFromSurfacePoint(t,e){return e.subVectors(t,this.center).normalize()}fromPoints(t){return se.fromPoints(t),se.getCenter(this.center),this.radius=this.center.distanceTo(se.max),this}applyMatrix4(t){return this.center.applyMatrix4(t),this.radius=this.radius*t.getMaxScale(),this}equals(t){return t.center.equals(this.center)&&t.radius===this.radius}toJSON(){return{type:this.constructor.name,center:this.center.toArray(new Array),radius:this.radius}}fromJSON(t){return this.center.fromArray(t.center),this.radius=t.radius,this}}const T=new l,ie=new l,Dt=new l,re=new l,Be=new l,Rt=new Q,Ps=new Q,qe=new k;class Ht{constructor(t=new l,e=new l){this.origin=t,this.direction=e}set(t,e){return this.origin=t,this.direction=e,this}copy(t){return this.origin.copy(t.origin),this.direction.copy(t.direction),this}clone(){return new this.constructor().copy(this)}at(t,e){return e.copy(this.direction).multiplyScalar(t).add(this.origin)}intersectBoundingSphere(t,e){T.subVectors(t.center,this.origin);const s=T.dot(this.direction),i=T.dot(T)-s*s,r=t.radius*t.radius;if(i>r)return null;const n=Math.sqrt(r-i),o=s-n,h=s+n;return o<0&&h<0?null:o<0?this.at(h,e):this.at(o,e)}intersectsBoundingSphere(t){const e=new l;let s;const i=e.subVectors(t.center,this.origin).dot(this.direction);return i<0?s=this.origin.squaredDistanceTo(t.center):(e.copy(this.direction).multiplyScalar(i).add(this.origin),s=e.squaredDistanceTo(t.center)),s<=t.radius*t.radius}intersectAABB(t,e){let s,i,r,n,o,h;const a=1/this.direction.x,c=1/this.direction.y,d=1/this.direction.z,p=this.origin;return a>=0?(s=(t.min.x-p.x)*a,i=(t.max.x-p.x)*a):(s=(t.max.x-p.x)*a,i=(t.min.x-p.x)*a),c>=0?(r=(t.min.y-p.y)*c,n=(t.max.y-p.y)*c):(r=(t.max.y-p.y)*c,n=(t.min.y-p.y)*c),s>n||r>i||((r>s||s!==s)&&(s=r),(n<i||i!==i)&&(i=n),d>=0?(o=(t.min.z-p.z)*d,h=(t.max.z-p.z)*d):(o=(t.max.z-p.z)*d,h=(t.min.z-p.z)*d),s>h||o>i)||((o>s||s!==s)&&(s=o),(h<i||i!==i)&&(i=h),i<0)?null:this.at(s>=0?s:i,e)}intersectsAABB(t){return this.intersectAABB(t,T)!==null}intersectPlane(t,e){let s;const i=t.normal.dot(this.direction);if(i===0)if(t.distanceToPoint(this.origin)===0)s=0;else return null;else s=-(this.origin.dot(t.normal)+t.constant)/i;return s>=0?this.at(s,e):null}intersectsPlane(t){const e=t.distanceToPoint(this.origin);return e===0||t.normal.dot(this.direction)*e<0}intersectOBB(t,e){return t.getSize(Be),qe.fromCenterAndSize(T.set(0,0,0),Be),Rt.fromMatrix3(t.rotation),Rt.setPosition(t.center),Le.copy(this).applyMatrix4(Rt.getInverse(Ps)),Le.intersectAABB(qe,e)?e.applyMatrix4(Rt):null}intersectsOBB(t){return this.intersectOBB(t,T)!==null}intersectConvexHull(t,e){const s=t.faces;let i=-1/0,r=1/0;for(let n=0,o=s.length;n<o;n++){const a=s[n].plane,c=a.distanceToPoint(this.origin),d=a.normal.dot(this.direction);if(c>0&&d>=0)return null;const p=d!==0?-c/d:0;if(!(p<=0)&&(d>0?r=Math.min(p,r):i=Math.max(p,i),i>r))return null}return i!==-1/0?this.at(i,e):this.at(r,e),e}intersectsConvexHull(t){return this.intersectConvexHull(t,T)!==null}intersectTriangle(t,e,s){const i=t.a,r=t.b,n=t.c;ie.subVectors(r,i),Dt.subVectors(n,i),re.crossVectors(ie,Dt);let o=this.direction.dot(re),h;if(o>0){if(e)return null;h=1}else if(o<0)h=-1,o=-o;else return null;T.subVectors(this.origin,i);const a=h*this.direction.dot(Dt.crossVectors(T,Dt));if(a<0)return null;const c=h*this.direction.dot(ie.cross(T));if(c<0||a+c>o)return null;const d=-h*T.dot(re);return d<0?null:this.at(d/o,s)}intersectBVH(t,e){return t.root.intersectRay(this,e)}intersectsBVH(t){return t.root.intersectsRay(this)}applyMatrix4(t){return this.origin.applyMatrix4(t),this.direction.transformDirection(t),this}equals(t){return t.origin.equals(this.origin)&&t.direction.equals(this.direction)}}const Le=new Ht,Ue=new Q,$=new l,Pt=new l,ne=new l,oe=new U,Is=new Ht(new l(0,0,0),new l(0,0,1));class Es extends N{constructor(t=new Array){super(),this.obstacles=t,this.brakingWeight=.2,this.dBoxMinLength=4}calculate(t,e){const s=this.obstacles;let i=null,r=1/0;const n=this.dBoxMinLength+t.getSpeed()/t.maxSpeed*this.dBoxMinLength;t.worldMatrix.getInverse(Ue);for(let o=0,h=s.length;o<h;o++){const a=s[o];if(a!==t&&($.copy(a.position).applyMatrix4(Ue),$.z>0&&Math.abs($.z)<n)){const c=a.boundingRadius+t.boundingRadius;Math.abs($.x)<c&&(oe.center.copy($),oe.radius=c,Is.intersectBoundingSphere(oe,ne),ne.z<r&&(r=ne.z,i=a,Pt.copy($)))}}if(i!==null){const o=1+(n-Pt.z)/n;e.x=(i.boundingRadius-Pt.x)*o,e.z=(i.boundingRadius-Pt.z)*this.brakingWeight,e.applyRotation(t.rotation)}return e}toJSON(){const t=super.toJSON();t.obstacles=new Array,t.brakingWeight=this.brakingWeight,t.dBoxMinLength=this.dBoxMinLength;for(let e=0,s=this.obstacles.length;e<s;e++)t.obstacles.push(this.obstacles[e].uuid);return t}fromJSON(t){return super.fromJSON(t),this.obstacles=t.obstacles,this.brakingWeight=t.brakingWeight,this.dBoxMinLength=t.dBoxMinLength,this}resolveReferences(t){const e=this.obstacles;for(let s=0,i=e.length;s<i;s++)e[s]=t.get(e[s])}}const he=new l,Ye=new l,We=new l,$e=new l;class Vs extends N{constructor(t=null,e=new l){super(),this.leader=t,this.offset=e,this._arrive=new $t,this._arrive.deceleration=1.5}calculate(t,e){const s=this.leader,i=this.offset;he.copy(i).applyMatrix4(s.worldMatrix),Ye.subVectors(he,t.position);const r=Ye.length()/(t.maxSpeed+s.getSpeed());return We.copy(s.velocity).multiplyScalar(r),$e.addVectors(he,We),this._arrive.target=$e,this._arrive.calculate(t,e),e}toJSON(){const t=super.toJSON();return t.leader=this.leader?this.leader.uuid:null,t.offset=this.offset,t}fromJSON(t){return super.fromJSON(t),this.leader=t.leader,this.offset=t.offset,this}resolveReferences(t){this.leader=t.get(this.leader)||null}}const ae=new l,ce=new l,He=new l,Ze=new l,Xe=new l;class ks extends N{constructor(t=null,e=1){super(),this.evader=t,this.predictionFactor=e,this._seek=new at}calculate(t,e){const s=this.evader;ae.subVectors(s.position,t.position),t.getDirection(ce),s.getDirection(He);const i=ae.dot(ce)>0,r=ce.dot(He)<-.95;if(i===!0&&r===!0)return this._seek.target=s.position,this._seek.calculate(t,e),e;let n=ae.length()/(t.maxSpeed+s.getSpeed());return n*=this.predictionFactor,Ze.copy(s.velocity).multiplyScalar(n),Xe.addVectors(s.position,Ze),this._seek.target=Xe,this._seek.calculate(t,e),e}toJSON(){const t=super.toJSON();return t.evader=this.evader?this.evader.uuid:null,t.predictionFactor=this.predictionFactor,t}fromJSON(t){return super.fromJSON(t),this.evader=t.evader,this.predictionFactor=t.predictionFactor,this}resolveReferences(t){this.evader=t.get(this.evader)||null}}const It=new l;class Cs extends N{constructor(){super()}calculate(t,e){const s=t.neighbors;for(let i=0,r=s.length;i<r;i++){const n=s[i];It.subVectors(t.position,n.position);let o=It.length();o===0&&(o=1e-4),It.normalize().divideScalar(o),e.add(It)}return e}}const Et=new l,le=new l;class Fs extends N{constructor(t=1,e=5,s=5){super(),this.radius=t,this.distance=e,this.jitter=s,this._targetLocal=new l,Bs(this.radius,this._targetLocal)}calculate(t,e,s){const i=this.jitter*s;return le.x=J.randFloat(-1,1)*i,le.z=J.randFloat(-1,1)*i,this._targetLocal.add(le),this._targetLocal.normalize(),this._targetLocal.multiplyScalar(this.radius),Et.copy(this._targetLocal),Et.z+=this.distance,Et.applyMatrix4(t.worldMatrix),e.subVectors(Et,t.position),e}toJSON(){const t=super.toJSON();return t.radius=this.radius,t.distance=this.distance,t.jitter=this.jitter,t._targetLocal=this._targetLocal.toArray(new Array),t}fromJSON(t){return super.fromJSON(t),this.radius=t.radius,this.distance=t.distance,this.jitter=t.jitter,this._targetLocal.fromArray(t._targetLocal),this}}function Bs(u,t){const e=Math.random()*Math.PI*2;t.x=u*Math.cos(e),t.z=u*Math.sin(e)}const Vt=new l;class Ke{constructor(t){this.vehicle=t,this.behaviors=new Array,this._steeringForce=new l,this._typesMap=new Map}add(t){return this.behaviors.push(t),this}remove(t){const e=this.behaviors.indexOf(t);return this.behaviors.splice(e,1),this}clear(){return this.behaviors.length=0,this}calculate(t,e){return this._calculateByOrder(t),e.copy(this._steeringForce)}_accumulate(t){const e=this._steeringForce.length(),s=this.vehicle.maxForce-e;return s<=0?!1:(t.length()>s&&t.normalize().multiplyScalar(s),this._steeringForce.add(t),!0)}_calculateByOrder(t){const e=this.behaviors;this._steeringForce.set(0,0,0);for(let s=0,i=e.length;s<i;s++){const r=e[s];if(r.active===!0&&(Vt.set(0,0,0),r.calculate(this.vehicle,Vt,t),Vt.multiplyScalar(r.weight),this._accumulate(Vt)===!1))return}}toJSON(){const t={type:"SteeringManager",behaviors:new Array},e=this.behaviors;for(let s=0,i=e.length;s<i;s++){const r=e[s];t.behaviors.push(r.toJSON())}return t}fromJSON(t){this.clear();const e=t.behaviors;for(let s=0,i=e.length;s<i;s++){const r=e[s],n=r.type;let o;switch(n){case"SteeringBehavior":o=new N().fromJSON(r);break;case"AlignmentBehavior":o=new As().fromJSON(r);break;case"ArriveBehavior":o=new $t().fromJSON(r);break;case"CohesionBehavior":o=new Ts().fromJSON(r);break;case"EvadeBehavior":o=new Js().fromJSON(r);break;case"FleeBehavior":o=new xs().fromJSON(r);break;case"FollowPathBehavior":o=new Ds().fromJSON(r);break;case"InterposeBehavior":o=new Rs().fromJSON(r);break;case"ObstacleAvoidanceBehavior":o=new Es().fromJSON(r);break;case"OffsetPursuitBehavior":o=new Vs().fromJSON(r);break;case"PursuitBehavior":o=new ks().fromJSON(r);break;case"SeekBehavior":o=new at().fromJSON(r);break;case"SeparationBehavior":o=new Cs().fromJSON(r);break;case"WanderBehavior":o=new Fs().fromJSON(r);break;default:const h=this._typesMap.get(n);if(h!==void 0)o=new h().fromJSON(r);else{v.warn("YUKA.SteeringManager: Unsupported steering behavior type:",n);continue}}this.add(o)}return this}registerType(t,e){return this._typesMap.set(t,e),this}resolveReferences(t){const e=this.behaviors;for(let s=0,i=e.length;s<i;s++)e[s].resolveReferences(t);return this}}class qs{constructor(t=10){this.count=t,this._history=new Array,this._slot=0;for(let e=0;e<this.count;e++)this._history[e]=new l}calculate(t,e){e.set(0,0,0),this._slot===this.count&&(this._slot=0),this._history[this._slot].copy(t),this._slot++;for(let s=0;s<this.count;s++)e.add(this._history[s]);return e.divideScalar(this.count),e}toJSON(){const t={type:this.constructor.name,count:this.count,_history:new Array,_slot:this._slot},e=this._history;for(let s=0,i=e.length;s<i;s++){const r=e[s];t._history.push(r.toArray(new Array))}return t}fromJSON(t){this.count=t.count,this._slot=t._slot;const e=t._history;this._history.length=0;for(let s=0,i=e.length;s<i;s++){const r=e[s];this._history.push(new l().fromArray(r))}return this}}const Ge=new l,kt=new l,Qe=new l,st=new l,je=new l;class Ls extends ys{constructor(){super(),this.mass=1,this.maxForce=100,this.steering=new Ke(this),this.smoother=null}update(t){return this.steering.calculate(t,Ge),Qe.copy(Ge).divideScalar(this.mass),this.velocity.add(Qe.multiplyScalar(t)),this.getSpeedSquared()>this.maxSpeed*this.maxSpeed&&(this.velocity.normalize(),this.velocity.multiplyScalar(this.maxSpeed)),kt.copy(this.velocity).multiplyScalar(t),st.copy(this.position).add(kt),this.updateOrientation===!0&&this.smoother===null&&this.getSpeedSquared()>1e-8&&this.lookAt(st),this.position.copy(st),this.updateOrientation===!0&&this.smoother!==null&&(this.smoother.calculate(this.velocity,je),kt.copy(je).multiplyScalar(t),st.copy(this.position).add(kt),this.lookAt(st)),this}toJSON(){const t=super.toJSON();return t.mass=this.mass,t.maxForce=this.maxForce,t.steering=this.steering.toJSON(),t.smoother=this.smoother?this.smoother.toJSON():null,t}fromJSON(t){return super.fromJSON(t),this.mass=t.mass,this.maxForce=t.maxForce,this.steering=new Ke(this).fromJSON(t.steering),this.smoother=t.smoother?new qs().fromJSON(t.smoother):null,this}resolveReferences(t){super.resolveReferences(t),this.steering.resolveReferences(t)}}class Wt{touching(){return!1}update(){return this}toJSON(){return{type:this.constructor.name}}fromJSON(){return this}}const ts=new U,es=new l;class Us extends Wt{constructor(t=new l){super(),this.size=t,this._aabb=new k}touching(t){return ts.set(t.position,t.boundingRadius),this._aabb.intersectsBoundingSphere(ts)}update(t){return t.getWorldPosition(es),this._aabb.fromCenterAndSize(es,this.size),this}toJSON(){const t=super.toJSON();return t.size=this.size.toArray(new Array),t}fromJSON(t){return super.fromJSON(t),this.size.fromArray(t.size),this}}const ue=new U;class Ys extends Wt{constructor(t=0){super(),this.radius=t,this._boundingSphere=new U}touching(t){return t.getWorldPosition(ue.center),ue.radius=t.boundingRadius,this._boundingSphere.intersectsBoundingSphere(ue)}update(t){return t.getWorldPosition(this._boundingSphere.center),this._boundingSphere.radius=this.radius,this}toJSON(){const t=super.toJSON();return t.radius=this.radius,t}fromJSON(t){return super.fromJSON(t),this.radius=t.radius,this}}class ss extends Me{constructor(t=new Wt){super(),this.region=t,this.canActivateTrigger=!1,this._typesMap=new Map}check(t){return this.region.touching(t)===!0&&this.execute(t),this}execute(){}updateRegion(){return this.region.update(this),this}toJSON(){const t=super.toJSON();return t.region=this.region.toJSON(),t}fromJSON(t){super.fromJSON(t);const e=t.region;let s=e.type;switch(s){case"TriggerRegion":this.region=new Wt().fromJSON(e);break;case"RectangularTriggerRegion":this.region=new Us().fromJSON(e);break;case"SphericalTriggerRegion":this.region=new Ys().fromJSON(e);break;default:const i=this._typesMap.get(s);i!==void 0?this.region=new i().fromJSON(e):v.warn("YUKA.Trigger: Unsupported trigger region type:",e.type)}return this}registerType(t,e){return this._typesMap.set(t,e),this}}const it=new Array;class Ni{constructor(){this.entities=new Array,this.spatialIndex=null,this._triggers=new Array,this._indexMap=new Map,this._typesMap=new Map,this._messageDispatcher=new _s}add(t){return this.entities.push(t),t.manager=this,this}remove(t){const e=this.entities.indexOf(t);return this.entities.splice(e,1),t.manager=null,this}clear(){return this.entities.length=0,this._messageDispatcher.clear(),this}getEntityByName(t){const e=this.entities;for(let s=0,i=e.length;s<i;s++){const r=e[s];if(r.name===t)return r}return null}update(t){const e=this.entities,s=this._triggers;for(let i=e.length-1;i>=0;i--){const r=e[i];this.updateEntity(r,t)}for(let i=s.length-1;i>=0;i--){const r=s[i];this.processTrigger(r)}return this._triggers.length=0,this._messageDispatcher.dispatchDelayedMessages(t),this}updateEntity(t,e){if(t.active===!0){this.updateNeighborhood(t),t._started===!1&&(t.start(),t._started=!0),t.update(e);const s=t.children;for(let n=s.length-1;n>=0;n--){const o=s[n];this.updateEntity(o,e)}if(t instanceof ss&&this._triggers.push(t),this.spatialIndex!==null){let n=this._indexMap.get(t)||-1;n=this.spatialIndex.updateEntity(t,n),this._indexMap.set(t,n)}const i=t._renderComponent,r=t._renderComponentCallback;i!==null&&r!==null&&r(t,i)}return this}updateNeighborhood(t){if(t.updateNeighborhood===!0){t.neighbors.length=0,this.spatialIndex!==null?this.spatialIndex.query(t.position,t.neighborhoodRadius,it):(it.length=0,it.push(...this.entities));const e=t.neighborhoodRadius*t.neighborhoodRadius;for(let s=0,i=it.length;s<i;s++){const r=it[s];t!==r&&r.active===!0&&t.position.squaredDistanceTo(r.position)<=e&&t.neighbors.push(r)}}return this}processTrigger(t){t.updateRegion();const e=this.entities;for(let s=e.length-1;s>=0;s--){const i=e[s];t!==i&&i.active===!0&&i.canActivateTrigger===!0&&t.check(i)}return this}sendMessage(t,e,s,i,r){return this._messageDispatcher.dispatch(t,e,s,i,r),this}toJSON(){const t={type:this.constructor.name,entities:new Array,_messageDispatcher:this._messageDispatcher.toJSON()};function e(s){t.entities.push(s.toJSON());for(let i=0,r=s.children.length;i<r;i++)e(s.children[i])}for(let s=0,i=this.entities.length;s<i;s++)e(this.entities[s]);return t}fromJSON(t){this.clear();const e=t.entities,s=t._messageDispatcher,i=new Map;for(let r=0,n=e.length;r<n;r++){const o=e[r],h=o.type;let a;switch(h){case"GameEntity":a=new Me().fromJSON(o);break;case"MovingEntity":a=new ys().fromJSON(o);break;case"Vehicle":a=new Ls().fromJSON(o);break;case"Trigger":a=new ss().fromJSON(o);break;default:const c=this._typesMap.get(h);if(c!==void 0)a=new c().fromJSON(o);else{v.warn("YUKA.EntityManager: Unsupported entity type:",h);continue}}i.set(a.uuid,a),a.parent===null&&this.add(a)}for(let r of i.values())r.resolveReferences(i);return this._messageDispatcher.fromJSON(s),this}registerType(t,e){return this._typesMap.set(t,e),this}}class Ai{constructor(){this._events=new Map}addEventListener(t,e){const s=this._events;s.has(t)===!1&&s.set(t,new Array);const i=s.get(t);i.indexOf(e)===-1&&i.push(e)}removeEventListener(t,e){const i=this._events.get(t);if(i!==void 0){const r=i.indexOf(e);r!==-1&&i.splice(r,1)}}hasEventListener(t,e){const i=this._events.get(t);return i!==void 0&&i.indexOf(e)!==-1}dispatchEvent(t){const s=this._events.get(t.type);if(s!==void 0){t.target=this;for(let i=0,r=s.length;i<r;i++)s[i].call(this,t)}}}const H=new l,de=new l,Ct=new l;class Ss{constructor(t=new l(0,0,1),e=0){this.normal=t,this.constant=e}set(t,e){return this.normal=t,this.constant=e,this}copy(t){return this.normal.copy(t.normal),this.constant=t.constant,this}clone(){return new this.constructor().copy(this)}distanceToPoint(t){return this.normal.dot(t)+this.constant}fromNormalAndCoplanarPoint(t,e){return this.normal.copy(t),this.constant=-e.dot(this.normal),this}fromCoplanarPoints(t,e,s){return H.subVectors(s,e).cross(de.subVectors(t,e)).normalize(),this.fromNormalAndCoplanarPoint(H,t),this}intersectPlane(t,e){Ct.crossVectors(this.normal,t.normal);const s=Ct.dot(Ct);return s===0?null:(H.copy(t.normal).multiplyScalar(this.constant),de.copy(this.normal).multiplyScalar(t.constant),e.crossVectors(H.sub(de),Ct).divideScalar(s),e)}intersectsPlane(t){const e=this.normal.dot(t.normal);return Math.abs(e)!==1}projectPoint(t,e){return H.copy(this.normal).multiplyScalar(this.distanceToPoint(t)),e.subVectors(t,H),e}equals(t){return t.normal.equals(this.normal)&&t.constant===this.constant}}const is=new U,z={a:new l,b:new l,c:new l},Z=new Ht,rs=new Ss,ns=new Q,pe=new l,V={a:new l,b:new l,c:new l};class bs{constructor(t=new Float32Array,e=null){this.vertices=t,this.indices=e,this.backfaceCulling=!0,this.aabb=new k,this.boundingSphere=new U,this.computeBoundingVolume()}computeBoundingVolume(){const t=this.vertices,e=new l,s=this.aabb,i=this.boundingSphere;s.min.set(1/0,1/0,1/0),s.max.set(-1/0,-1/0,-1/0);for(let r=0,n=t.length;r<n;r+=3)e.x=t[r],e.y=t[r+1],e.z=t[r+2],s.expand(e);return s.getCenter(i.center),i.radius=i.center.distanceTo(s.max),this}intersectRay(t,e,s,i,r=null){if(is.copy(this.boundingSphere).applyMatrix4(e),t.intersectsBoundingSphere(is)&&(e.getInverse(ns),Z.copy(t).applyMatrix4(ns),Z.intersectsAABB(this.aabb))){const n=this.vertices,o=this.indices;let h=1/0,a=!1;if(o===null){for(let c=0,d=n.length;c<d;c+=9)if(z.a.set(n[c],n[c+1],n[c+2]),z.b.set(n[c+3],n[c+4],n[c+5]),z.c.set(n[c+6],n[c+7],n[c+8]),Z.intersectTriangle(z,this.backfaceCulling,i)!==null)if(s){const p=i.squaredDistanceTo(Z.origin);p<h&&(h=p,pe.copy(i),V.a.copy(z.a),V.b.copy(z.b),V.c.copy(z.c),a=!0)}else{a=!0;break}}else for(let c=0,d=o.length;c<d;c+=3){const p=o[c],f=o[c+1],y=o[c+2],m=3;if(z.a.set(n[p*m],n[p*m+1],n[p*m+2]),z.b.set(n[f*m],n[f*m+1],n[f*m+2]),z.c.set(n[y*m],n[y*m+1],n[y*m+2]),Z.intersectTriangle(z,this.backfaceCulling,i)!==null)if(s){const x=i.squaredDistanceTo(Z.origin);x<h&&(h=x,pe.copy(i),V.a.copy(z.a),V.b.copy(z.b),V.c.copy(z.c),a=!0)}else{a=!0;break}}if(a)return s&&(i.copy(pe),z.a.copy(V.a),z.b.copy(V.b),z.c.copy(V.c)),i.applyMatrix4(e),r!==null&&(rs.fromCoplanarPoints(z.a,z.b,z.c),r.copy(rs.normal),r.transformDirection(e)),i}return null}toTriangleSoup(){const t=this.indices;if(t){const e=this.vertices,s=new Float32Array(t.length*3);for(let i=0,r=t.length;i<r;i++){const n=t[i],o=3;s[i*o]=e[n*o],s[i*o+1]=e[n*o+1],s[i*o+2]=e[n*o+2]}return new bs(s)}else return this}toJSON(){const t={type:this.constructor.name};return t.indices={type:this.indices?this.indices.constructor.name:"null",data:this.indices?Array.from(this.indices):null},t.vertices=Array.from(this.vertices),t.backfaceCulling=this.backfaceCulling,t.aabb=this.aabb.toJSON(),t.boundingSphere=this.boundingSphere.toJSON(),t}fromJSON(t){switch(this.aabb=new k().fromJSON(t.aabb),this.boundingSphere=new U().fromJSON(t.boundingSphere),this.backfaceCulling=t.backfaceCulling,this.vertices=new Float32Array(t.vertices),t.indices.type){case"Uint16Array":this.indices=new Uint16Array(t.indices.data);break;case"Uint32Array":this.indices=new Uint32Array(t.indices.data);break;case"null":this.indices=null;break}return this}}class Ws{constructor(){this._previousTime=0,this._currentTime=0,this._delta=0,this._elapsed=0,this._timescale=1,this._useFixedDelta=!1,this._fixedDelta=16.67,this._usePageVisibilityAPI=typeof document<"u"&&document.hidden!==void 0,this._usePageVisibilityAPI===!0&&(this._pageVisibilityHandler=$s.bind(this),document.addEventListener("visibilitychange",this._pageVisibilityHandler,!1))}disableFixedDelta(){return this._useFixedDelta=!1,this}dispose(){return this._usePageVisibilityAPI===!0&&document.removeEventListener("visibilitychange",this._pageVisibilityHandler),this}enableFixedDelta(){return this._useFixedDelta=!0,this}getDelta(){return this._delta/1e3}getElapsed(){return this._elapsed/1e3}getFixedDelta(){return this._fixedDelta/1e3}getTimescale(){return this._timescale}reset(){return this._currentTime=this._now(),this}setFixedDelta(t){return this._fixedDelta=t*1e3,this}setTimescale(t){return this._timescale=t,this}update(){return this._useFixedDelta===!0?this._delta=this._fixedDelta:(this._previousTime=this._currentTime,this._currentTime=this._now(),this._delta=this._currentTime-this._previousTime),this._delta*=this._timescale,this._elapsed+=this._delta,this}_now(){return(typeof performance>"u"?Date:performance).now()}}function $s(){document.hidden===!1&&this.reset()}class Ti{constructor(t=0){this.updateFrequency=t,this._time=new Ws,this._nextUpdateTime=0}ready(){this._time.update();const t=this._time.getElapsed();return t>=this._nextUpdateTime?(this._nextUpdateTime=t+1/this.updateFrequency,!0):!1}}class vs{clearDegreeOfMembership(){}getDegreeOfMembership(){}updateDegreeOfMembership(){}toJSON(){return{type:this.constructor.name}}}class q extends vs{constructor(t=new Array){super(),this.terms=t}clearDegreeOfMembership(){const t=this.terms;for(let e=0,s=t.length;e<s;e++)t[e].clearDegreeOfMembership();return this}updateDegreeOfMembership(t){const e=this.terms;for(let s=0,i=e.length;s<i;s++)e[s].updateDegreeOfMembership(t);return this}toJSON(){const t=super.toJSON();t.terms=new Array;for(let e=0,s=this.terms.length;e<s;e++){const i=this.terms[e];i instanceof q?t.terms.push(i.toJSON()):t.terms.push(i.uuid)}return t}}class Hs extends q{constructor(){const t=Array.from(arguments);super(t)}getDegreeOfMembership(){const t=this.terms;let e=1/0;for(let s=0,i=t.length;s<i;s++){const n=t[s].getDegreeOfMembership();n<e&&(e=n)}return e}}class Zs extends q{constructor(t=null){const e=t!==null?[t]:new Array;super(e)}clearDegreeOfMembership(){return this.terms[0].clearDegreeOfMembership(),this}getDegreeOfMembership(){const e=this.terms[0].getDegreeOfMembership();return Math.sqrt(e)}updateDegreeOfMembership(t){return this.terms[0].updateDegreeOfMembership(Math.sqrt(t)),this}}class Xs extends q{constructor(){const t=Array.from(arguments);super(t)}getDegreeOfMembership(){const t=this.terms;let e=-1/0;for(let s=0,i=t.length;s<i;s++){const n=t[s].getDegreeOfMembership();n>e&&(e=n)}return e}}class Ks extends q{constructor(t=null){const e=t!==null?[t]:new Array;super(e)}clearDegreeOfMembership(){return this.terms[0].clearDegreeOfMembership(),this}getDegreeOfMembership(){const e=this.terms[0].getDegreeOfMembership();return e*e}updateDegreeOfMembership(t){return this.terms[0].updateDegreeOfMembership(t*t),this}}class Zt extends vs{constructor(t=0){super(),this.degreeOfMembership=0,this.representativeValue=t,this.left=0,this.right=0,this._uuid=null}get uuid(){return this._uuid===null&&(this._uuid=J.generateUUID()),this._uuid}computeDegreeOfMembership(){}clearDegreeOfMembership(){return this.degreeOfMembership=0,this}getDegreeOfMembership(){return this.degreeOfMembership}updateDegreeOfMembership(t){return t>this.degreeOfMembership&&(this.degreeOfMembership=t),this}toJSON(){const t=super.toJSON();return t.degreeOfMembership=this.degreeOfMembership,t.representativeValue=this.representativeValue,t.left=this.left,t.right=this.right,t.uuid=this.uuid,t}fromJSON(t){return this.degreeOfMembership=t.degreeOfMembership,this.representativeValue=t.representativeValue,this.left=t.left,this.right=t.right,this._uuid=t.uuid,this}}class Gs extends Zt{constructor(t=0,e=0,s=0){const i=(e+t)/2;super(i),this.left=t,this.midpoint=e,this.right=s}computeDegreeOfMembership(t){const e=this.midpoint,s=this.left,i=this.right;return t>=s&&t<=e?1:t>e&&t<=i?1/(i-e)*(i-t):0}toJSON(){const t=super.toJSON();return t.midpoint=this.midpoint,t}fromJSON(t){return super.fromJSON(t),this.midpoint=t.midpoint,this}}class Qs extends Zt{constructor(t=0,e=0,s=0){const i=(e+s)/2;super(i),this.left=t,this.midpoint=e,this.right=s}computeDegreeOfMembership(t){const e=this.midpoint,s=this.left,i=this.right;return t>=s&&t<=e?1/(e-s)*(t-s):t>e&&t<=i?1:0}toJSON(){const t=super.toJSON();return t.midpoint=this.midpoint,t}fromJSON(t){return super.fromJSON(t),this.midpoint=t.midpoint,this}}class js extends Zt{constructor(t=0,e=0,s=0){super(e),this.left=t,this.midpoint=e,this.right=s}computeDegreeOfMembership(t){const e=this.left,s=this.right;return t>=e&&t<=s?1:0}toJSON(){const t=super.toJSON();return t.midpoint=this.midpoint,t}fromJSON(t){return super.fromJSON(t),this.midpoint=t.midpoint,this}}class ti extends Zt{constructor(t=0,e=0,s=0){super(e),this.left=t,this.midpoint=e,this.right=s}computeDegreeOfMembership(t){const e=this.midpoint,s=this.left,i=this.right;return t>=s&&t<=e?1/(e-s)*(t-s):t>e&&t<=i?1/(i-e)*(i-t):0}toJSON(){const t=super.toJSON();return t.midpoint=this.midpoint,t}fromJSON(t){return super.fromJSON(t),this.midpoint=t.midpoint,this}}class ei{constructor(t=null,e=null){this.antecedent=t,this.consequence=e}initConsequence(){return this.consequence.clearDegreeOfMembership(),this}evaluate(){return this.consequence.updateDegreeOfMembership(this.antecedent.getDegreeOfMembership()),this}toJSON(){const t={},e=this.antecedent,s=this.consequence;return t.type=this.constructor.name,t.antecedent=e instanceof q?e.toJSON():e.uuid,t.consequence=s instanceof q?s.toJSON():s.uuid,t}fromJSON(t,e){function s(i){if(typeof i=="string"){const r=i;return e.get(r)||null}else{const r=i.type;let n;switch(r){case"FuzzyAND":n=new Hs;break;case"FuzzyOR":n=new Xs;break;case"FuzzyVERY":n=new Ks;break;case"FuzzyFAIRLY":n=new Zs;break;default:v.error("YUKA.FuzzyRule: Unsupported operator type:",r);return}const o=i.terms;for(let h=0,a=o.length;h<a;h++)n.terms.push(s(o[h]));return n}}return this.antecedent=s(t.antecedent),this.consequence=s(t.consequence),this}}class si{constructor(){this.fuzzySets=new Array,this.minRange=1/0,this.maxRange=-1/0}add(t){return this.fuzzySets.push(t),t.left<this.minRange&&(this.minRange=t.left),t.right>this.maxRange&&(this.maxRange=t.right),this}remove(t){const e=this.fuzzySets,s=e.indexOf(t);e.splice(s,1),this.minRange=1/0,this.maxRange=-1/0;for(let i=0,r=e.length;i<r;i++){const n=e[i];n.left<this.minRange&&(this.minRange=n.left),n.right>this.maxRange&&(this.maxRange=n.right)}return this}fuzzify(t){if(t<this.minRange||t>this.maxRange){v.warn("YUKA.FuzzyVariable: Value for fuzzification out of range.");return}const e=this.fuzzySets;for(let s=0,i=e.length;s<i;s++){const r=e[s];r.degreeOfMembership=r.computeDegreeOfMembership(t)}return this}defuzzifyMaxAv(){const t=this.fuzzySets;let e=0,s=0;for(let i=0,r=t.length;i<r;i++){const n=t[i];e+=n.degreeOfMembership,s+=n.representativeValue*n.degreeOfMembership}return e===0?0:s/e}defuzzifyCentroid(t=10){const e=this.fuzzySets,s=(this.maxRange-this.minRange)/t;let i=0,r=0;for(let n=1;n<=t;n++){const o=this.minRange+n*s;for(let h=0,a=e.length;h<a;h++){const c=e[h],d=Math.min(c.degreeOfMembership,c.computeDegreeOfMembership(o));i+=d,r+=o*d}}return i===0?0:r/i}toJSON(){const t={type:this.constructor.name,fuzzySets:new Array,minRange:this.minRange.toString(),maxRange:this.maxRange.toString()};for(let e=0,s=this.fuzzySets.length;e<s;e++){const i=this.fuzzySets[e];t.fuzzySets.push(i.toJSON())}return t}fromJSON(t){this.minRange=parseFloat(t.minRange),this.maxRange=parseFloat(t.maxRange);for(let e=0,s=t.fuzzySets.length;e<s;e++){const i=t.fuzzySets[e];switch(i.type){case"LeftShoulderFuzzySet":this.fuzzySets.push(new Gs().fromJSON(i));break;case"RightShoulderFuzzySet":this.fuzzySets.push(new Qs().fromJSON(i));break;case"SingletonFuzzySet":this.fuzzySets.push(new js().fromJSON(i));break;case"TriangularFuzzySet":this.fuzzySets.push(new ti().fromJSON(i));break;default:v.error("YUKA.FuzzyVariable: Unsupported fuzzy set type:",i.type)}}return this}}class ht{constructor(){this.rules=new Array,this.flvs=new Map}addFLV(t,e){return this.flvs.set(t,e),this}removeFLV(t){return this.flvs.delete(t),this}addRule(t){return this.rules.push(t),this}removeRule(t){const e=this.rules,s=e.indexOf(t);return e.splice(s,1),this}fuzzify(t,e){return this.flvs.get(t).fuzzify(e),this}defuzzify(t,e=ht.DEFUZ_TYPE.MAXAV){const s=this.flvs,i=this.rules;this._initConsequences();for(let o=0,h=i.length;o<h;o++)i[o].evaluate();const r=s.get(t);let n;switch(e){case ht.DEFUZ_TYPE.MAXAV:n=r.defuzzifyMaxAv();break;case ht.DEFUZ_TYPE.CENTROID:n=r.defuzzifyCentroid();break;default:v.warn("YUKA.FuzzyModule: Unknown defuzzification method:",e),n=r.defuzzifyMaxAv()}return n}_initConsequences(){const t=this.rules;for(let e=0,s=t.length;e<s;e++)t[e].initConsequence();return this}toJSON(){const t={rules:new Array,flvs:new Array},e=this.rules;for(let i=0,r=e.length;i<r;i++)t.rules.push(e[i].toJSON());const s=this.flvs;for(let[i,r]of s)t.flvs.push({name:i,flv:r.toJSON()});return t}fromJSON(t){const e=new Map,s=t.flvs;for(let r=0,n=s.length;r<n;r++){const o=s[r],h=o.name,a=new si().fromJSON(o.flv);this.addFLV(h,a);for(let c of a.fuzzySets)e.set(c.uuid,c)}const i=t.rules;for(let r=0,n=i.length;r<n;r++){const o=i[r],h=new ei().fromJSON(o,e);this.addRule(h)}return this}}ht.DEFUZ_TYPE=Object.freeze({MAXAV:0,CENTROID:1});class _{constructor(t=null){this.owner=t,this.status=_.STATUS.INACTIVE}activate(){}execute(){}terminate(){}handleMessage(){return!1}active(){return this.status===_.STATUS.ACTIVE}inactive(){return this.status===_.STATUS.INACTIVE}completed(){return this.status===_.STATUS.COMPLETED}failed(){return this.status===_.STATUS.FAILED}replanIfFailed(){return this.failed()===!0&&(this.status=_.STATUS.INACTIVE),this}activateIfInactive(){return this.inactive()===!0&&(this.status=_.STATUS.ACTIVE,this.activate()),this}toJSON(){return{type:this.constructor.name,owner:this.owner.uuid,status:this.status}}fromJSON(t){return this.owner=t.owner,this.status=t.status,this}resolveReferences(t){return this.owner=t.get(this.owner)||null,this}}_.STATUS=Object.freeze({ACTIVE:"active",INACTIVE:"inactive",COMPLETED:"completed",FAILED:"failed"});class _e extends _{constructor(t=null){super(t),this.subgoals=new Array}addSubgoal(t){return this.subgoals.unshift(t),this}removeSubgoal(t){const e=this.subgoals.indexOf(t);return this.subgoals.splice(e,1),this}clearSubgoals(){const t=this.subgoals;for(let e=0,s=t.length;e<s;e++)t[e].terminate();return t.length=0,this}currentSubgoal(){const t=this.subgoals.length;return t>0?this.subgoals[t-1]:null}executeSubgoals(){const t=this.subgoals;for(let s=t.length-1;s>=0;s--){const i=t[s];if(i.completed()===!0||i.failed()===!0)i instanceof _e&&i.clearSubgoals(),i.terminate(),t.pop();else break}const e=this.currentSubgoal();return e!==null?(e.activateIfInactive(),e.execute(),e.completed()===!0&&t.length>1?_.STATUS.ACTIVE:e.status):_.STATUS.COMPLETED}hasSubgoals(){return this.subgoals.length>0}handleMessage(t){const e=this.currentSubgoal();return e!==null?e.handleMessage(t):!1}toJSON(){const t=super.toJSON();t.subgoals=new Array;for(let e=0,s=this.subgoals.length;e<s;e++){const i=this.subgoals[e];t.subgoals.push(i.toJSON())}return t}resolveReferences(t){super.resolveReferences(t);for(let e=0,s=this.subgoals.length;e<s;e++)this.subgoals[e].resolveReferences(t);return this}}class Ji{constructor(t=1){this.characterBias=t}calculateDesirability(){return 0}setGoal(){}toJSON(){return{type:this.constructor.name,characterBias:this.characterBias}}fromJSON(t){return this.characterBias=t.characterBias,this}}class Di extends _e{constructor(t=null){super(t),this.evaluators=new Array,this._typesMap=new Map}activate(){this.arbitrate()}execute(){this.activateIfInactive();const t=this.executeSubgoals();(t===_.STATUS.COMPLETED||t===_.STATUS.FAILED)&&(this.status=_.STATUS.INACTIVE)}terminate(){this.clearSubgoals()}addEvaluator(t){return this.evaluators.push(t),this}removeEvaluator(t){const e=this.evaluators.indexOf(t);return this.evaluators.splice(e,1),this}arbitrate(){const t=this.evaluators;let e=-1,s=null;for(let i=0,r=t.length;i<r;i++){const n=t[i];let o=n.calculateDesirability(this.owner);o*=n.characterBias,o>=e&&(e=o,s=n)}return s!==null?s.setGoal(this.owner):v.error("YUKA.Think: Unable to determine goal evaluator for game entity:",this.owner),this}toJSON(){const t=super.toJSON();t.evaluators=new Array;for(let e=0,s=this.evaluators.length;e<s;e++){const i=this.evaluators[e];t.evaluators.push(i.toJSON())}return t}fromJSON(t){super.fromJSON(t);const e=this._typesMap;this.evaluators.length=0,this.terminate();for(let i=0,r=t.evaluators.length;i<r;i++){const n=t.evaluators[i],o=n.type,h=e.get(o);if(h!==void 0){const a=new h().fromJSON(n);this.evaluators.push(a)}else{v.warn("YUKA.Think: Unsupported goal evaluator type:",o);continue}}function s(i){const r=i.type,n=e.get(r);if(n!==void 0){const o=new n().fromJSON(i),h=i.subgoals;if(h!==void 0)for(let a=0,c=h.length;a<c;a++){const d=s(h[a]);d&&o.subgoals.push(d)}return o}else{v.warn("YUKA.Think: Unsupported goal evaluator type:",r);return}}for(let i=0,r=t.subgoals.length;i<r;i++){const n=s(t.subgoals[i]);n&&this.subgoals.push(n)}return this}registerType(t,e){return this._typesMap.set(t,e),this}}class zs{constructor(t=-1,e=-1,s=0){this.from=t,this.to=e,this.cost=s}copy(t){return this.from=t.from,this.to=t.to,this.cost=t.cost,this}clone(){return new this.constructor().copy(this)}toJSON(){return{type:this.constructor.name,from:this.from,to:this.to,cost:this.cost}}fromJSON(t){return this.from=t.from,this.to=t.to,this.cost=t.cost,this}}class Os{constructor(t=-1){this.index=t}toJSON(){return{type:this.constructor.name,index:this.index}}fromJSON(t){return this.index=t.index,this}}class ii{constructor(){this.digraph=!1,this._nodes=new Map,this._edges=new Map}addNode(t){const e=t.index;return this._nodes.set(e,t),this._edges.set(e,new Array),this}addEdge(t){let e;if(e=this._edges.get(t.from),e.push(t),this.digraph===!1){const s=t.clone();s.from=t.to,s.to=t.from,e=this._edges.get(t.to),e.push(s)}return this}getNode(t){return this._nodes.get(t)||null}getEdge(t,e){if(this.hasNode(t)&&this.hasNode(e)){const s=this._edges.get(t);for(let i=0,r=s.length;i<r;i++){const n=s[i];if(n.to===e)return n}}return null}getNodes(t){return t.length=0,t.push(...this._nodes.values()),t}getEdgesOfNode(t,e){const s=this._edges.get(t);return s!==void 0&&(e.length=0,e.push(...s)),e}getNodeCount(){return this._nodes.size}getEdgeCount(){let t=0;for(const e of this._edges.values())t+=e.length;return t}removeNode(t){if(this._nodes.delete(t.index),this.digraph===!1){const e=this._edges.get(t.index);for(const s of e){const i=this._edges.get(s.to);for(let r=i.length-1;r>=0;r--){const n=i[r];if(n.to===t.index){const o=i.indexOf(n);i.splice(o,1);break}}}}else for(const e of this._edges.values())for(let s=e.length-1;s>=0;s--){const i=e[s];if(!this.hasNode(i.to)||!this.hasNode(i.from)){const r=e.indexOf(i);e.splice(r,1)}}return this._edges.delete(t.index),this}removeEdge(t){const e=this._edges.get(t.from);if(e!==void 0){const s=e.indexOf(t);if(e.splice(s,1),this.digraph===!1){const i=this._edges.get(t.to);for(let r=0,n=i.length;r<n;r++){const o=i[r];if(o.to===t.from){const h=i.indexOf(o);i.splice(h,1);break}}}}return this}hasNode(t){return this._nodes.has(t)}hasEdge(t,e){if(this.hasNode(t)&&this.hasNode(e)){const s=this._edges.get(t);for(let i=0,r=s.length;i<r;i++)if(s[i].to===e)return!0;return!1}else return!1}clear(){return this._nodes.clear(),this._edges.clear(),this}toJSON(){const t={type:this.constructor.name,digraph:this.digraph},e=new Array,s=new Array;for(let[i,r]of this._nodes.entries()){const n=new Array;this.getEdgesOfNode(i,n);for(let o=0,h=n.length;o<h;o++)e.push(n[o].toJSON());s.push(r.toJSON())}return t._edges=e,t._nodes=s,t}fromJSON(t){this.digraph=t.digraph;for(let e=0,s=t._nodes.length;e<s;e++)this.addNode(new Os().fromJSON(t._nodes[e]));for(let e=0,s=t._edges.length;e<s;e++)this.addEdge(new zs().fromJSON(t._edges[e]));return this}}class ri{static calculate(t,e,s){const i=t.getNode(e),r=t.getNode(s);return i.position.distanceTo(r.position)}}class ni{constructor(t=oi){this.data=new Array,this.length=0,this.compare=t}push(t){this.data.push(t),this.length++,this._up(this.length-1)}pop(){if(this.length===0)return null;const t=this.data[0];return this.length--,this.length>0&&(this.data[0]=this.data[this.length],this._down(0)),this.data.pop(),t}peek(){return this.data[0]||null}_up(t){const e=this.data,s=this.compare,i=e[t];for(;t>0;){const r=t-1>>1,n=e[r];if(s(i,n)>=0)break;e[t]=n,t=r}e[t]=i}_down(t){const e=this.data,s=this.compare,i=e[t],r=this.length>>1;for(;t<r;){let n=(t<<1)+1,o=n+1,h=e[n];if(o<this.length&&s(e[o],h)<0&&(n=o,h=e[o]),s(h,i)>=0)break;e[t]=h,t=n}e[t]=i}}function oi(u,t){return u<t?-1:u>t?1:0}class hi{constructor(t=null,e=-1,s=-1){this.graph=t,this.source=e,this.target=s,this.found=!1,this.heuristic=ri,this._cost=new Map,this._shortestPathTree=new Map,this._searchFrontier=new Map}search(){const t=new Array,e=new ni(ai);for(e.push({cost:0,index:this.source});e.length>0;){const i=e.pop().index;if(!this._shortestPathTree.has(i)){if(this._searchFrontier.has(i)===!0&&this._shortestPathTree.set(i,this._searchFrontier.get(i)),i===this.target)return this.found=!0,this;this.graph.getEdgesOfNode(i,t);for(let r=0,n=t.length;r<n;r++){const o=t[r],h=(this._cost.get(i)||0)+o.cost,a=this.heuristic.calculate(this.graph,o.to,this.target),c=h+a;(this._searchFrontier.has(o.to)===!1||h<this._cost.get(o.to))&&(this._cost.set(o.to,h),this._searchFrontier.set(o.to,o),e.push({cost:c,index:o.to}))}}}return this.found=!1,this}getPath(){const t=new Array;if(this.found===!1||this.target===-1)return t;let e=this.target;for(t.push(e);e!==this.source;)e=this._shortestPathTree.get(e).from,t.unshift(e);return t}getSearchTree(){return[...this._shortestPathTree.values()]}clear(){return this.found=!1,this._cost.clear(),this._shortestPathTree.clear(),this._searchFrontier.clear(),this}}function ai(u,t){return u.cost<t.cost?-1:u.cost>t.cost?1:0}const O=new l,K=new l,G=new l,ci=new l(1,0,0),li=new l(0,1,0),ui=new l(0,0,1),B={a:new l,b:new l,c:new l},os=new l,X=new Array;class Ri{constructor(t=2,e=1,s=10){this.branchingFactor=t,this.primitivesPerNode=e,this.depth=s,this.root=null}fromMeshGeometry(t){this.root=new Ne,t.indices!==null&&(t=t.toTriangleSoup());const e=t.vertices;for(let i=0,r=e.length;i<r;i++)this.root.primitives.push(e[i]);const s=this.root.primitives;for(let i=0,r=s.length;i<r;i+=9)O.fromArray(s,i),K.fromArray(s,i+3),G.fromArray(s,i+6),O.add(K).add(G).divideScalar(3),this.root.centroids.push(O.x,O.y,O.z);return this.root.build(this.branchingFactor,this.primitivesPerNode,this.depth,1),this}traverse(t){return this.root.traverse(t),this}}class Ne{constructor(){this.parent=null,this.children=new Array,this.boundingVolume=new k,this.primitives=new Array,this.centroids=new Array}root(){return this.parent===null}leaf(){return this.children.length===0}getDepth(){let t=0,e=this.parent;for(;e!==null;)e=e.parent,t++;return t}traverse(t){t(this);for(let e=0,s=this.children.length;e<s;e++)this.children[e].traverse(t);return this}build(t,e,s,i){this.computeBoundingVolume();const r=this.primitives.length/9,n=Math.floor(r/t);if(i<=s&&n>=e){this.split(t);for(let o=0;o<t;o++)this.children[o].build(t,e,s,i+1)}return this}computeBoundingVolume(){const t=this.primitives,e=this.boundingVolume;e.min.set(1/0,1/0,1/0),e.max.set(-1/0,-1/0,-1/0);for(let s=0,i=t.length;s<i;s+=3)O.x=t[s],O.y=t[s+1],O.z=t[s+2],e.expand(O);return this}computeSplitAxis(){let t,e,s=e=t=-1/0,i,r,n=r=i=1/0;const o=this.centroids;for(let d=0,p=o.length;d<p;d+=3){const f=o[d],y=o[d+1],m=o[d+2];f>t&&(t=f),y>e&&(e=y),m>s&&(s=m),f<i&&(i=f),y<r&&(r=y),m<n&&(n=m)}const h=t-i,a=e-r,c=s-n;return h>a&&h>c?ci:a>c?li:ui}split(t){const e=this.centroids,s=this.primitives;for(let c=0;c<t;c++)this.children[c]=new Ne,this.children[c].parent=this;const i=this.computeSplitAxis(),r=new Array;for(let c=0,d=e.length;c<d;c+=3){O.fromArray(e,c);const p=O.dot(i),f=c/3;r.push({index:f,p})}r.sort(di);const n=r.length,o=Math.floor(n/t);var h=0,a=0;for(let c=0;c<n;c++){a++,a>o&&h<t-1&&(a=1,h++);const d=this.children[h],p=r[c].index,f=p*9;O.fromArray(s,f),K.fromArray(s,f+3),G.fromArray(s,f+6),d.primitives.push(O.x,O.y,O.z),d.primitives.push(K.x,K.y,K.z),d.primitives.push(G.x,G.y,G.z),O.fromArray(e,p*3),d.centroids.push(O.x,O.y,O.z)}return this.centroids.length=0,this.primitives.length=0,this}intersectRay(t,e){if(t.intersectAABB(this.boundingVolume,e)!==null)if(this.leaf()===!0){const s=this.primitives;for(let i=0,r=s.length;i<r;i+=9)B.a.fromArray(s,i),B.b.fromArray(s,i+3),B.c.fromArray(s,i+6),t.intersectTriangle(B,!0,e)!==null&&X.push(e.clone())}else for(let s=0,i=this.children.length;s<i;s++)this.children[s].intersectRay(t,e);if(this.root()===!0)if(X.length>0){let s=1/0;for(let i=0,r=X.length;i<r;i++){const n=t.origin.squaredDistanceTo(X[i]);n<s&&(s=n,e.copy(X[i]))}return X.length=0,e}else return null;else return null}intersectsRay(t){if(t.intersectAABB(this.boundingVolume,os)!==null)if(this.leaf()===!0){const e=this.primitives;for(let s=0,i=e.length;s<i;s+=9)if(B.a.fromArray(e,s),B.b.fromArray(e,s+3),B.c.fromArray(e,s+6),t.intersectTriangle(B,!0,os)!==null)return!0;return!1}else{for(let e=0,s=this.children.length;e<s;e++)if(this.children[e].intersectsRay(t)===!0)return!0;return!1}else return!1}}function di(u,t){return u.p-t.p}const hs=new l,Ft=new l;class Ms{constructor(t=new l,e=new l){this.from=t,this.to=e}set(t,e){return this.from=t,this.to=e,this}copy(t){return this.from.copy(t.from),this.to.copy(t.to),this}clone(){return new this.constructor().copy(this)}delta(t){return t.subVectors(this.to,this.from)}at(t,e){return this.delta(e).multiplyScalar(t).add(this.from)}closestPointToPoint(t,e,s){const i=this.closestPointToPointParameter(t,e);return this.at(i,s)}closestPointToPointParameter(t,e=!0){hs.subVectors(t,this.from),Ft.subVectors(this.to,this.from);const s=Ft.dot(Ft);let r=Ft.dot(hs)/s;return e&&(r=J.clamp(r,0,1)),r}equals(t){return t.from.equals(this.from)&&t.to.equals(this.to)}}class pi{constructor(t=new l){this.vertex=t,this.next=null,this.prev=null,this.twin=null,this.polygon=null}tail(){return this.prev?this.prev.vertex:null}head(){return this.vertex}length(){const t=this.tail(),e=this.head();return t!==null?t.distanceTo(e):-1}squaredLength(){const t=this.tail(),e=this.head();return t!==null?t.squaredDistanceTo(e):-1}linkOpponent(t){return this.twin=t,t.twin=this,this}getDirection(t){return t.subVectors(this.vertex,this.prev.vertex).normalize()}}class as{constructor(){this.centroid=new l,this.edge=null,this.plane=new Ss}fromContour(t){const e=new Array;if(t.length<3)return v.error("YUKA.Polygon: Unable to create polygon from contour. It needs at least three points."),this;for(let s=0,i=t.length;s<i;s++){const r=new pi(t[s]);e.push(r)}for(let s=0,i=e.length;s<i;s++){let r,n,o;s===0?(r=e[s],n=e[i-1],o=e[s+1]):s===i-1?(r=e[s],n=e[s-1],o=e[0]):(r=e[s],n=e[s-1],o=e[s+1]),r.prev=n,r.next=o,r.polygon=this}return this.edge=e[0],this.plane.fromCoplanarPoints(t[0],t[1],t[2]),this}computeCentroid(){const t=this.centroid;let e=this.edge,s=0;t.set(0,0,0);do t.add(e.vertex),s++,e=e.next;while(e!==this.edge);return t.divideScalar(s),this}contains(t,e=.001){const s=this.plane;let i=this.edge;do{const n=i.tail(),o=i.head();if(fe(n,o,t)===!1)return!1;i=i.next}while(i!==this.edge);const r=s.distanceToPoint(t);return!(Math.abs(r)>e)}convex(t=!0){let e=this.edge;do{const s=e.tail(),i=e.head(),r=e.next.head();if(t){if(fe(s,i,r)===!1)return!1}else if(fe(r,i,s)===!1)return!1;e=e.next}while(e!==this.edge);return!0}coplanar(t=.001){const e=this.plane;let s=this.edge;do{const i=e.distanceToPoint(s.vertex);if(Math.abs(i)>t)return!1;s=s.next}while(s!==this.edge);return!0}distanceToPoint(t){return this.plane.distanceToPoint(t)}getContour(t){let e=this.edge;t.length=0;do t.push(e.vertex),e=e.next;while(e!==this.edge);return t}}function fe(u,t,e){return J.area(u,t,e)>=0}class fi extends zs{constructor(t=-1,e=-1,s=0){super(t,e,s)}}class gi extends Os{constructor(t=-1,e=new l,s={}){super(t),this.position=e,this.userData=s}}class mi{constructor(){this.portalEdges=new Array}push(t,e){return this.portalEdges.push({left:t,right:e}),this}generate(){const t=this.portalEdges,e=new Array;let s,i,r,n=0,o=0,h=0;s=t[0].left,i=t[0].left,r=t[0].right,e.push(s);for(let a=1,c=t.length;a<c;a++){const d=t[a].left,p=t[a].right;if(J.area(s,r,p)<=0)if(s===r||J.area(s,i,p)>0)r=p,h=a;else{e.push(i),s=i,n=o,i=s,r=s,o=n,h=n,a=n;continue}if(J.area(s,i,d)>=0)if(s===i||J.area(s,r,d)<0)i=d,o=a;else{e.push(r),s=r,n=h,i=s,r=s,o=n,h=n,a=n;continue}}return(e.length===0||e[e.length-1]!==t[t.length-1].left)&&e.push(t[t.length-1].left),e}}class Pi{constructor(){this._nodeMap=new Map}init(t){const e=t.graph,s=new Array;this.clear(),e.getNodes(s);for(let i=0,r=s.length;i<r;i++){const n=s[i];for(let o=0,h=s.length;o<h;o++){const a=s[o],c=t.findPath(n.position,a.position),d=yi(c);this.set(n.index,a.index,d)}}return this}clear(){return this._nodeMap.clear(),this}set(t,e,s){const i=this._nodeMap;return i.has(t)===!1&&i.set(t,new Map),i.get(t).set(e,s),this}get(t,e){return this._nodeMap.get(t).get(e)}size(){return this._nodeMap.size}toJSON(){const t={nodes:new Array};for(let[e,s]of this._nodeMap.entries())t.nodes.push({index:e,costs:Array.from(s)});return t}fromJSON(t){const e=t.nodes;for(let s=0,i=e.length;s<i;s++){const r=e[s],n=r.index,o=new Map(r.costs);this._nodeMap.set(n,o)}return this}}function yi(u){let t=0;for(let e=0,s=u.length-1;e<s;e++){const i=u[e],r=u[e+1];t+=i.distanceTo(r)}return t}const ge=new l,me=new l,ye=new l,rt=new l,nt=new Ms,xe=new Array,we={edge:null,closestPoint:new l};class xi{constructor(){this.graph=new ii,this.graph.digraph=!0,this.regions=new Array,this.spatialIndex=null,this.epsilonCoplanarTest=.001,this.epsilonContainsTest=1,this.mergeConvexRegions=!0,this._borderEdges=new Array}fromPolygons(t){this.clear();const e=new Array,s=new Array;for(let i=0,r=t.length;i<r;i++){const n=t[i];let o=n.edge;do e.push(o),o=o.next;while(o!==n.edge);this.regions.push(n)}for(let i=0,r=e.length;i<r;i++){let n=e[i];if(n.twin===null)for(let o=i+1,h=e.length;o<h;o++){let a=e[o];if(n.tail().equals(a.head())&&n.head().equals(a.tail())){n.linkOpponent(a);const c=n.squaredLength();s.push({cost:c,edge:n});break}}}return s.sort(wi),this._buildRegions(s),this._buildGraph(),this}clear(){return this.graph.clear(),this.regions.length=0,this.spatialIndex=null,this}getClosestRegion(t){const e=this.regions;let s=null,i=1/0;for(let r=0,n=e.length;r<n;r++){const o=e[r],h=t.squaredDistanceTo(o.centroid);h<i&&(i=h,s=o)}return s}getRandomRegion(){const t=this.regions;let e=Math.floor(Math.random()*t.length);return e===t.length&&(e=t.length-1),t[e]}getRegionForPoint(t,e=.001){let s;if(this.spatialIndex!==null){const i=this.spatialIndex.getIndexForPosition(t);s=this.spatialIndex.cells[i].entries}else s=this.regions;for(let i=0,r=s.length;i<r;i++){const n=s[i];if(n.contains(t,e)===!0)return n}return null}getNodeIndex(t){return this.regions.indexOf(t)}findPath(t,e){const s=this.graph,i=new Array;let r=this.getRegionForPoint(t,this.epsilonContainsTest),n=this.getRegionForPoint(e,this.epsilonContainsTest);if((r===null||n===null)&&(r===null&&(r=this.getClosestRegion(t)),n===null&&(n=this.getClosestRegion(e))),r===n)return i.push(new l().copy(t)),i.push(new l().copy(e)),i;{const o=this.getNodeIndex(r),h=this.getNodeIndex(n),a=new hi(s,o,h);if(a.search(),a.found===!0){const c=a.getPath(),d=new mi;d.push(t,t);const p={left:null,right:null};for(let f=0,y=c.length-1;f<y;f++){const m=this.regions[c[f]],x=this.regions[c[f+1]];this._getPortalEdge(m,x,p),d.push(p.left,p.right)}d.push(e,e),i.push(...d.generate())}return i}}clampMovement(t,e,s,i){let r=this.getRegionForPoint(s,this.epsilonContainsTest);if(r===null){if(t===null)throw new Error("YUKA.NavMesh.clampMovement(): No current region available.");this._getClosestBorderEdge(e,we);const n=we.edge,o=we.closestPoint;n.getDirection(me);const h=ye.subVectors(s,e).length();let a=0;h!==0&&(ye.divideScalar(h),a=me.dot(ye)),rt.copy(o).add(me.multiplyScalar(a*h)),nt.set(n.prev.vertex,n.vertex);const c=nt.closestPointToPointParameter(rt,!1);if(c>=0&&c<=1)i.copy(rt);else{if(r=this.getRegionForPoint(rt,this.epsilonContainsTest),r!==null)return i.copy(rt),r;i.copy(e)}return t}else return r}updateSpatialIndex(){if(this.spatialIndex!==null){this.spatialIndex.makeEmpty();const t=this.regions;for(let e=0,s=t.length;e<s;e++){const i=t[e];this.spatialIndex.addPolygon(i)}}return this}_buildRegions(t){const e=this.regions,s={};if(this.mergeConvexRegions===!0)for(let i=0,r=t.length;i<r;i++){const n=t[i];let o=n.edge;s.prev=o.prev,s.next=o.next,s.prevTwin=o.twin.prev,s.nextTwin=o.twin.next,o.prev.next=o.twin.next,o.next.prev=o.twin.prev,o.twin.prev.next=o.next,o.twin.next.prev=o.prev;const h=o.polygon;if(h.edge=o.prev,h.convex()===!0&&h.coplanar(this.epsilonCoplanarTest)===!0){let a=h.edge;do a.polygon=h,a=a.next;while(a!==h.edge);const c=e.indexOf(n.edge.twin.polygon);e.splice(c,1)}else s.prev.next=o,s.next.prev=o,s.prevTwin.next=o.twin,s.nextTwin.prev=o.twin,h.edge=o}for(let i=0,r=e.length;i<r;i++){const n=e[i];n.computeCentroid();let o=n.edge;do o.twin===null&&this._borderEdges.push(o),o=o.next;while(o!==n.edge)}}_buildGraph(){const t=this.graph,e=this.regions,s=new Array;for(let i=0,r=e.length;i<r;i++){const n=e[i],o=new Array;s.push(o);let h=n.edge;do{if(h.twin!==null){const a=this.getNodeIndex(h.twin.polygon);if(o.push(a),t.hasNode(this.getNodeIndex(h.polygon))===!1){const c=new gi(this.getNodeIndex(h.polygon),h.polygon.centroid);t.addNode(c)}}h=h.next}while(h!==n.edge)}for(let i=0,r=s.length;i<r;i++){const n=s[i],o=i;for(let h=0,a=n.length;h<a;h++){const c=n[h];if(o!==c&&t.hasEdge(o,c)===!1){const d=t.getNode(o),p=t.getNode(c),f=d.position.distanceTo(p.position);t.addEdge(new fi(o,c,f))}}}return this}_getClosestBorderEdge(t,e){let s,i=1/0;if(this.spatialIndex!==null){xe.length=0;const r=this.spatialIndex.getIndexForPosition(t),n=this.spatialIndex.cells[r].entries;for(let o=0,h=n.length;o<h;o++){const a=n[o];let c=a.edge;do c.twin===null&&xe.push(c),c=c.next;while(c!==a.edge)}s=xe}else s=this._borderEdges;for(let r=0,n=s.length;r<n;r++){const o=s[r];nt.set(o.prev.vertex,o.vertex);const h=nt.closestPointToPointParameter(t);nt.at(h,ge);const a=ge.squaredDistanceTo(t);a<i&&(i=a,e.edge=o,e.closestPoint.copy(ge))}return this}_getPortalEdge(t,e,s){let i=t.edge;do{if(i.twin!==null&&i.twin.polygon===e)return s.left=i.prev.vertex,s.right=i.vertex,s;i=i.next}while(i!==t.edge);return s.left=null,s.right=null,s}}function wi(u,t){return u.cost<t.cost?1:u.cost>t.cost?-1:0}class Ii{load(t,e){return new Promise((s,i)=>{fetch(t).then(r=>{if(r.status>=200&&r.status<300)return r.arrayBuffer();{const n=new Error(r.statusText||r.status);return n.response=r,Promise.reject(n)}}).then(r=>this.parse(r,t,e)).then(r=>{s(r)}).catch(r=>{v.error("YUKA.NavMeshLoader: Unable to load navigation mesh.",r),i(r)})})}parse(t,e,s){const i=new Si,r=new TextDecoder;let n;r.decode(new Uint8Array(t,0,4))===Mi?(i.parseBinary(t),n=i.extensions.get("BINARY").content):n=r.decode(new Uint8Array(t));const h=JSON.parse(n);if(h.asset===void 0||h.asset.version[0]<2)throw new Error("YUKA.NavMeshLoader: Unsupported asset version.");{const a=bi(e);return i.parse(h,a,s)}}}class Si{constructor(){this.json=null,this.path=null,this.cache=new Map,this.extensions=new Map}parse(t,e,s){return this.json=t,this.path=e,this.getDependency("mesh",0).then(i=>{const r=this.parseGeometry(i),n=new xi;return s&&(s.epsilonCoplanarTest!==void 0&&(n.epsilonCoplanarTest=s.epsilonCoplanarTest),s.mergeConvexRegions!==void 0&&(n.mergeConvexRegions=s.mergeConvexRegions)),n.fromPolygons(r)})}parseGeometry(t){const e=t.index,s=t.position,i=new Array,r=new Array;for(let n=0,o=s.length;n<o;n+=3){const h=new l;h.x=s[n+0],h.y=s[n+1],h.z=s[n+2],i.push(h)}if(e)for(let n=0,o=e.length;n<o;n+=3){const h=e[n+0],a=e[n+1],c=e[n+2],d=[i[h],i[a],i[c]],p=new as().fromContour(d);r.push(p)}else for(let n=0,o=i.length;n<o;n+=3){const h=[i[n+0],i[n+1],i[n+2]],a=new as().fromContour(h);r.push(a)}return r}getDependencies(t){const e=this.cache;let s=e.get(t);if(!s){const i=this.json[t+(t==="mesh"?"es":"s")]||new Array;s=Promise.all(i.map((r,n)=>this.getDependency(t,n))),e.set(t,s)}return s}getDependency(t,e){const s=this.cache,i=t+":"+e;let r=s.get(i);if(r===void 0){switch(t){case"accessor":r=this.loadAccessor(e);break;case"buffer":r=this.loadBuffer(e);break;case"bufferView":r=this.loadBufferView(e);break;case"mesh":r=this.loadMesh(e);break;default:throw new Error("Unknown type: "+t)}s.set(i,r)}return r}loadBuffer(t){const s=this.json.buffers[t];return s.uri===void 0&&t===0?Promise.resolve(this.extensions.get("BINARY").body):new Promise((i,r)=>{const n=vi(s.uri,this.path);fetch(n).then(o=>o.arrayBuffer()).then(o=>{i(o)}).catch(o=>{v.error("YUKA.NavMeshLoader: Unable to load buffer.",o),r(o)})})}loadBufferView(t){const s=this.json.bufferViews[t];return this.getDependency("buffer",s.buffer).then(i=>{const r=s.byteLength||0,n=s.byteOffset||0;return i.slice(n,n+r)})}loadAccessor(t){const s=this.json.accessors[t];return this.getDependency("bufferView",s.bufferView).then(i=>{const r=zi[s.type],n=Oi[s.componentType],o=s.byteOffset||0;return new n(i,o,s.count*r)})}loadMesh(t){const s=this.json.meshes[t];return this.getDependencies("accessor").then(i=>{const r=s.primitives[0];if(r.mode!==void 0&&r.mode!==4)throw new Error("YUKA.NavMeshLoader: Invalid geometry format. Please ensure to represent your geometry as triangles.");return{index:i[r.indices],position:i[r.attributes.POSITION],normal:i[r.attributes.NORMAL]}})}parseBinary(t){const e=new DataView(t,Se);let s=0;const i=new TextDecoder;let r=null,n=null;for(;s<e.byteLength;){const o=e.getUint32(s,!0);s+=4;const h=e.getUint32(s,!0);if(s+=4,h===cs.JSON){const a=new Uint8Array(t,Se+s,o);r=i.decode(a)}else if(h===cs.BIN){const a=Se+s;n=t.slice(a,a+o)}s+=o}this.extensions.set("BINARY",{content:r,body:n})}}function bi(u=""){const t=u.lastIndexOf("/");return t===-1?"./":u.substr(0,t+1)}function vi(u,t){return typeof u!="string"||u===""?"":/^(https?:)?\/\//i.test(u)||/^data:.*,.*$/i.test(u)||/^blob:.*$/i.test(u)?u:t+u}const zi={SCALAR:1,VEC2:2,VEC3:3,VEC4:4,MAT2:4,MAT3:9,MAT4:16},Oi={5120:Int8Array,5121:Uint8Array,5122:Int16Array,5123:Uint16Array,5125:Uint32Array,5126:Float32Array},Mi="glTF",Se=12,cs={JSON:1313821514,BIN:5130562};class ls{constructor(t=new k){this.aabb=t,this.entries=new Array}add(t){return this.entries.push(t),this}remove(t){const e=this.entries.indexOf(t);return this.entries.splice(e,1),this}makeEmpty(){return this.entries.length=0,this}empty(){return this.entries.length===0}intersects(t){return this.aabb.intersectsAABB(t)}toJSON(){const t={type:this.constructor.name,aabb:this.aabb.toJSON(),entries:new Array},e=this.entries;for(let s=0,i=e.length;s<i;s++)t.entries.push(e[s].uuid);return t}fromJSON(t){return this.aabb.fromJSON(t.aabb),this.entries=t.entries.slice(),this}resolveReferences(t){const e=this.entries;for(let s=0,i=e.length;s<i;s++)e[s]=t.get(e[s]);return this}}const Bt=new l,ot=new k,us=new Array;class Ei{constructor(t,e,s,i,r,n){this.cells=new Array,this.width=t,this.height=e,this.depth=s,this.cellsX=i,this.cellsY=r,this.cellsZ=n,this._halfWidth=this.width/2,this._halfHeight=this.height/2,this._halfDepth=this.depth/2,this._min=new l(-this._halfWidth,-this._halfHeight,-this._halfDepth),this._max=new l(this._halfWidth,this._halfHeight,this._halfDepth);const o=this.width/this.cellsX,h=this.height/this.cellsY,a=this.depth/this.cellsZ;for(let c=0;c<this.cellsX;c++){const d=c*o-this._halfWidth;for(let p=0;p<this.cellsY;p++){const f=p*h-this._halfHeight;for(let y=0;y<this.cellsZ;y++){const m=y*a-this._halfDepth,x=new l,g=new l;x.set(d,f,m),g.x=x.x+o,g.y=x.y+h,g.z=x.z+a;const w=new k(x,g),S=new ls(w);this.cells.push(S)}}}}updateEntity(t,e=-1){const s=this.getIndexForPosition(t.position);return e!==s&&(this.addEntityToPartition(t,s),e!==-1&&this.removeEntityFromPartition(t,e)),s}addEntityToPartition(t,e){return this.cells[e].add(t),this}removeEntityFromPartition(t,e){return this.cells[e].remove(t),this}getIndexForPosition(t){Bt.copy(t).clamp(this._min,this._max);let e=Math.abs(Math.floor(this.cellsX*(Bt.x+this._halfWidth)/this.width)),s=Math.abs(Math.floor(this.cellsY*(Bt.y+this._halfHeight)/this.height)),i=Math.abs(Math.floor(this.cellsZ*(Bt.z+this._halfDepth)/this.depth));return e===this.cellsX&&(e=this.cellsX-1),s===this.cellsY&&(s=this.cellsY-1),i===this.cellsZ&&(i=this.cellsZ-1),e*this.cellsY*this.cellsZ+s*this.cellsZ+i}query(t,e,s){const i=this.cells;s.length=0,ot.min.copy(t).subScalar(e),ot.max.copy(t).addScalar(e);for(let r=0,n=i.length;r<n;r++){const o=i[r];o.empty()===!1&&o.intersects(ot)===!0&&s.push(...o.entries)}return s}makeEmpty(){const t=this.cells;for(let e=0,s=t.length;e<s;e++)t[e].makeEmpty();return this}addPolygon(t){const e=this.cells;t.getContour(us),ot.fromPoints(us);for(let s=0,i=e.length;s<i;s++){const r=e[s];r.intersects(ot)===!0&&r.add(t)}return this}toJSON(){const t={type:this.constructor.name,cells:new Array,width:this.width,height:this.height,depth:this.depth,cellsX:this.cellsX,cellsY:this.cellsY,cellsZ:this.cellsZ,_halfWidth:this._halfWidth,_halfHeight:this._halfHeight,_halfDepth:this._halfDepth,_min:this._min.toArray(new Array),_max:this._max.toArray(new Array)};for(let e=0,s=this.cells.length;e<s;e++)t.cells.push(this.cells[e].toJSON());return t}fromJSON(t){this.cells.length=0,this.width=t.width,this.height=t.height,this.depth=t.depth,this.cellsX=t.cellsX,this.cellsY=t.cellsY,this.cellsZ=t.cellsZ,this._halfWidth=t._halfWidth,this._halfHeight=t._halfHeight,this._halfDepth=t._halfHeight,this._min.fromArray(t._min),this._max.fromArray(t._max);for(let e=0,s=t.cells.length;e<s;e++)this.cells.push(new ls().fromJSON(t.cells[e]));return this}resolveReferences(t){for(let e=0,s=this.cells.length;e<s;e++)this.cells[e].resolveReferences(t);return this}}class ds{constructor(t=null){this.entity=t,this.timeBecameVisible=-1/0,this.timeLastSensed=-1/0,this.lastSensedPosition=new l,this.visible=!1}toJSON(){return{type:this.constructor.name,entity:this.entity.uuid,timeBecameVisible:this.timeBecameVisible.toString(),timeLastSensed:this.timeLastSensed.toString(),lastSensedPosition:this.lastSensedPosition.toArray(new Array),visible:this.visible}}fromJSON(t){return this.entity=t.entity,this.timeBecameVisible=parseFloat(t.timeBecameVisible),this.timeLastSensed=parseFloat(t.timeLastSensed),this.lastSensedPosition.fromArray(t.lastSensedPosition),this.visible=t.visible,this}resolveReferences(t){return this.entity=t.get(this.entity)||null,this}}class Vi{constructor(t=null){this.owner=t,this.records=new Array,this.recordsMap=new Map,this.memorySpan=1}getRecord(t){return this.recordsMap.get(t)}createRecord(t){const e=new ds(t);return this.records.push(e),this.recordsMap.set(t,e),this}deleteRecord(t){const e=this.getRecord(t),s=this.records.indexOf(e);return this.records.splice(s,1),this.recordsMap.delete(t),this}hasRecord(t){return this.recordsMap.has(t)}clear(){return this.records.length=0,this.recordsMap.clear(),this}getValidMemoryRecords(t,e){const s=this.records;e.length=0;for(let i=0,r=s.length;i<r;i++){const n=s[i];t-n.timeLastSensed<=this.memorySpan&&e.push(n)}return e}toJSON(){const t={type:this.constructor.name,owner:this.owner.uuid,records:new Array,memorySpan:this.memorySpan},e=this.records;for(let s=0,i=e.length;s<i;s++){const r=e[s];t.records.push(r.toJSON())}return t}fromJSON(t){this.owner=t.owner,this.memorySpan=t.memorySpan;const e=t.records;for(let s=0,i=e.length;s<i;s++){const r=e[s],n=new ds().fromJSON(r);this.records.push(n)}return this}resolveReferences(t){this.owner=t.get(this.owner)||null;const e=this.records;for(let s=0,i=e.length;s<i;s++){const r=e[s];r.resolveReferences(t),this.recordsMap.set(r.entity,r)}return this}}const qt=new l,ps=new l,be=new Ht,fs=new l,Lt=new l;class ki{constructor(t=null){this.owner=t,this.fieldOfView=Math.PI,this.range=1/0,this.obstacles=new Array}addObstacle(t){return this.obstacles.push(t),this}removeObstacle(t){const e=this.obstacles.indexOf(t);return this.obstacles.splice(e,1),this}visible(t){const e=this.owner,s=this.obstacles;e.getWorldPosition(Lt),qt.subVectors(t,Lt);const i=qt.length();if(i>this.range||(e.getWorldDirection(ps),ps.angleTo(qt)>this.fieldOfView*.5))return!1;be.origin.copy(Lt),be.direction.copy(qt).divideScalar(i||1);for(let n=0,o=s.length;n<o;n++)if(s[n].lineOfSightTest(be,fs)!==null&&fs.squaredDistanceTo(Lt)<=i*i)return!1;return!0}toJSON(){const t={type:this.constructor.name,owner:this.owner.uuid,fieldOfView:this.fieldOfView,range:this.range.toString()};t.obstacles=new Array;for(let e=0,s=this.obstacles.length;e<s;e++){const i=this.obstacles[e];t.obstacles.push(i.uuid)}return t}fromJSON(t){this.owner=t.owner,this.fieldOfView=t.fieldOfView,this.range=parseFloat(t.range);for(let e=0,s=t.obstacles.length;e<s;e++){const i=t.obstacles[e];this.obstacles.push(i)}return this}resolveReferences(t){this.owner=t.get(this.owner)||null;const e=this.obstacles;for(let s=0,i=e.length;s<i;s++)e[s]=t.get(e[s]);return this}}const gs=new l,ve=new l,ze=new l,Ut=new Ms,ms=new l;class Ci extends N{constructor(t=new ws,e=.1,s=1){super(),this.path=t,this.radius=e,this.predictionFactor=s,this._seek=new at}calculate(t,e){const s=this.path;gs.copy(t.velocity).multiplyScalar(this.predictionFactor),ve.addVectors(t.position,gs);let i=1/0,r=s._waypoints.length;r=s.loop===!0?r:r-1;for(let n=0;n<r;n++){Ut.from=s._waypoints[n],s.loop===!0&&n===r-1?Ut.to=s._waypoints[0]:Ut.to=s._waypoints[n+1],Ut.closestPointToPoint(ve,!0,ze);const o=ve.squaredDistanceTo(ze);o<i&&(i=o,ms.copy(ze))}return i>this.radius*this.radius&&s._waypoints.length>1&&(this._seek.target=ms,this._seek.calculate(t,e)),e}toJSON(){const t=super.toJSON();return t.path=this.path.toJSON(),t.radius=this.radius,t.predictionFactor=this.predictionFactor,t}fromJSON(t){return super.fromJSON(t),this.path.fromJSON(t.path),this.radius=t.radius,this.predictionFactor=t.predictionFactor,this}}class Fi{execute(){}}class Bi{constructor(){this.tasks=new Array,this.options={timeout:1e3},this._active=!1,this._handler=_i.bind(this),this._taskHandle=0}enqueue(t){return this.tasks.push(t),this}update(){return this.tasks.length>0?this._active===!1&&(this._taskHandle=requestIdleCallback(this._handler,this.options),this._active=!0):this._active=!1,this}}function _i(u){const t=this.tasks;for(;u.timeRemaining()>0&&t.length>0;)t[0].execute(),t.shift();t.length>0?(this._taskHandle=requestIdleCallback(this._handler,this.options),this._active=!0):(this._taskHandle=0,this._active=!1)}export{k as A,Ri as B,Pi as C,Ai as E,ht as F,Me as G,v as L,J as M,Ii as N,Ci as O,Yt as Q,Ht as R,Ys as S,ss as T,l as V,_ as a,_e as b,Ji as c,si as d,Gs as e,ti as f,Qs as g,ei as h,Hs as i,Ti as j,Ls as k,Di as l,Vi as m,Ds as n,at as o,ki as p,ys as q,Fi as r,Bi as s,Ni as t,Ws as u,bs as v,Ei as w};
//# sourceMappingURL=yuka-BscLIxFQ.js.map
